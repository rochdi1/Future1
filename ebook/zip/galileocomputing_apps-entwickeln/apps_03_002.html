<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
      <meta name="title" content="Galileo Computing :: Apps entwickeln für iPhone und iPad - 3 Aufwachen &#8211; analoger Wecker">
      <meta name="author" content="Klaus M. Rodewig, Clemens Wagner">
      <meta name="publisher" content="Galileo Press 2011">
      <meta name="copyright" content="Galileo Press 2011">
      <meta name="Desription" content="Apps entwickeln für iPhone und iPad - Das Praxisbuch - 3 Aufwachen &#8211; analoger Wecker">
      <meta name="robots" content="INDEX,FOLLOW">
      <meta http-equiv="content-language" content="de">
      <title>Galileo Computing :: Apps entwickeln für iPhone und iPad - 3 Aufwachen &#8211; analoger
         Wecker
      </title>
      <link rel="stylesheet" type="text/css" href="common/galileo_open.css">
      <link rel="stylesheet" type="text/css" href="common/prettify.css">
      <link rel="stylesheet" type="text/css" media="screen" href="common/css/lightbox.css">
      &nbsp; &nbsp; &nbsp;                  <script type="text/javascript" src="common/js/prototype.js"></script>
      &nbsp; &nbsp; &nbsp;                  <script src="common/js/scriptaculous.js?load=effects,builder"></script>
      &nbsp; &nbsp; &nbsp;                  <script type="text/javascript" src="common/js/lightbox.js"></script><link rel="prev" href="apps_03_001.html">
      <link rel="next" href="apps_03_003.html"><script type="text/javascript" src="common/prettify.js"></script><script type="text/javascript" src="common/openwin.js"></script></head>
   <body vlink="#000099" link="#000099" alink="#000099" onload="prettyPrint()">
      <table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#000066">
         <tr>
            <td height="74" valign="bottom" colspan="2"><a href="http://www.galileocomputing.de/katalog/openbook/?GPP=opAppiP"><img src="common/galileocomputing_openbook.gif" width="200" height="56" border="0" alt="Galileo Computing < openbook &gt;" title="Galileo Computing < openbook &gt;"></a></td>
            <td width="80" height="74"><a href="http://www.galileocomputing.de/?GPP=opAppiP"><img src="common/galileocomputing.gif" border="0" alt="Galileo Computing - Professionelle Bücher. Auch für Einsteiger." title="Galileo Computing - Professionelle Bücher. Auch für Einsteiger."></a></td>
         </tr>
      </table>
      <div align="right"><a href="http://www.galileocomputing.de/?GPP=opAppiP" class="navnav">Professionelle Bücher. Auch für Einsteiger.</a></div><br><table class="tbl" border="0" cellpadding="0" cellspacing="0" width="100%">
         <tbody>
            <tr>
               <td width="190" valign="top">
                  <table class="tbl1" border="0" cellpadding="3" cellspacing="0" width="190" align="left">
                     <tbody>
                        <tr>
                           <td class="tbl2"><a class="nav" href="index.html">Inhaltsverzeichnis</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="apps_00_widmung_001.html#"></a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="apps_00_geleitwort_001.html#dodtpfad62f21-21f9-4eae-9038-c462dc2de850">Geleitwort des Gutachters</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="apps_00_vorwort_001.html#dodtp134aa4f5-3ea1-4d2b-90ec-625e9ad04995">Vorwort</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="apps_01_001.html#dodtp06116df0-71a6-4127-9c90-87cc60beb89d">1 Einführung</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="apps_02_001.html#dodtp13428fe8-22e7-48ed-b301-c766518dcaac">2 Einstieg in die Praxis</a></td>
                        </tr>
                        <tr>
                           <td><a class="navh" href="#dodtpd90d1a51-f4d6-4634-a164-a45ebd6f9dff">3 Aufwachen &#8211; analoger Wecker</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="apps_04_001.html#dodtpa5a111c6-3a92-4be9-aa3a-ed64f8951ac6">4 Daten, Tabellen und Controller</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="apps_05_001.html#dodtpa5dbcb97-8e52-44af-b2a1-d51145cf8406">5 Animationen und Layer</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="apps_06_001.html#dodtp610fd647-93cb-4bff-b94e-30d1cceb28fc">6 Programmieren, aber sicher</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="apps_07_001.html#dodtp35da27e0-4c50-417c-a28d-f5907117d740">7 Jahrmarkt der Nützlichkeiten</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="apps_anhang_a_dvd-inhalt_001.html#dodtp71232b80-1f13-4c5a-88ac-de2264b674f7">A Die Buch-DVD</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="stichwort.html">Stichwort</a></td>
                        </tr>
                        <tr>
                           <td><br><a href="http://download2.galileo-press.de/openbook/galileocomputing_apps-entwickeln.zip" class="navnav"><strong>Download:</strong><br>- ZIP, ca. 23,6 MB</a></td>
                        </tr>
                        <tr>
                           <td><a href="http://www.galileo-press.de/3521?GPP=opAppiP" class="navnav">Buch bestellen</a></td>
                        </tr>
                        <tr>
                           <td><a class="navnav" href="#kommentar">Ihre Meinung?</a><br><br></td>
                        </tr>
                     </tbody>
                  </table>
               </td>
               <td width="10"><img src="common/spacer10.gif" width="10" height="10" alt="Spacer"></td>
               <td width="85%" valign="top">
                  <div align="center">
                     <table width="98%" border="0" cellpadding="0" cellspacing="0" bgcolor="#FFFFFF">
                        <tbody>
                           <tr>
                              <td width="100%" class="start" colspan="1" height="22" align="center">
                                 <table width="100%" border="0" cellspacing="0" cellpadding="0">
                                    <tbody>
                                       <tr>
                                          <td width="25%">
                                             <div align="left"><a href="apps_03_001.html" class="navnav"> &lt;&lt; zurück</a></div>
                                          </td>
                                          <td width="49%">
                                             <div align="center"><a href="http://www.galileocomputing.de/?GPP=opAppiP" class="navnav">Galileo Computing</a> / <a href="http://www.galileocomputing.de/katalog/openbook/?GPP=opAppiP" class="navnav">
                                                   &lt;openbook&gt;</a> / <a href="index.html" class="navnav">Apps entwickeln für iPhone und iPad</a></div>
                                          </td>
                                          <td width="25%">
                                             <div align="right"><a href="apps_03_003.html" class="navnav">vor &gt;&gt; </a></div>
                                          </td>
                                       </tr>
                                    </tbody>
                                 </table>
                              </td>
                           </tr>
                           <tr>
                              <td width="100%" valign="top">
                                 <table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
                                    <tbody>
                                       <tr>
                                          <td colspan="2"><a href="http://www.galileocomputing.de/?GPP=opAppiP" class="buchtitel">Apps entwickeln für iPhone und iPad</a><span class="autor"> von Klaus M. Rodewig, Clemens Wagner</span><br><span class="untertitel">Das Praxisbuch</span></td>
                                       </tr>
                                       <tr>
                                          <td valign="top" width="211">
                                             <dl>
                                                <dt><a href="http://www.galileo-press.de/3521?GPP=opAppiP" class="navnav"><img src="common/9783836214636.jpg" border="0" alt="Buch: Apps entwickeln für iPhone und iPad" title="Buch: Apps entwickeln für iPhone und iPad"></a></dt>
                                                <dd><br><a href="http://www.galileo-press.de/3521?GPP=opAppiP"><span class="autor"><strong>Apps entwickeln für iPhone und iPad</strong><br><pressinfo>geb., mit DVD<br>515 S., 49,90 Euro<br>Galileo Computing<br>ISBN 978-3-8362-1463-6
                                                         <br><br>Die <strong>Neuauflage</strong> des Buches erhalten Sie in unserem Online-Shop - <em>versandkostenfrei</em> innerhalb Deutschlands und Österreichs.<br><a class="navnav" href="http://www.galileo-press.de/3521?GPP=opAppiP"><img src="common/pfeil_rechts5.gif" alt="" border="0">Zum Online-Shop</a></span></span></a></dd>
                                             </dl>
                                          </td>
                                          <td width="80%">
                                             <table border="0">
                                                <tbody>
                                                   <tr>
                                                      <td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline" colspan="3" class="kap"><strong><a href="apps_03_001.html#dodtpd90d1a51-f4d6-4634-a164-a45ebd6f9dff" class="navnav">3 Aufwachen &#8211; analoger Wecker</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline" colspan="2"><strong><a href="apps_03_001.html#dodtp523deab6-b894-4553-bc57-f19b8c82711c" class="navnav">3.1 Eigene View-Klassen in Cocoa Touch</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_001.html#dodtp453496f8-2506-4078-9d48-f2ae841048ec" class="navnav">3.1.1 Zeichnen in Cocoa Touch</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_001.html#dodtpbeef7b9e-a920-4d0a-b8c8-018fd73786a2" class="navnav">3.1.2 Zeitberechnung</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_001.html#dodtp368e550c-41e2-45fe-a426-af8e69e230eb" class="navnav">3.1.3 View-Erzeugung über NIB-Dateien</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_001.html#dodtpa7215b74-eb08-4a84-947c-6c11dfd1ac69" class="navnav">3.1.4 Aktualisierung der Zeitanzeige</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_001.html#dodtpf63ee996-c5eb-434d-b03c-56a8017b0cd7" class="navnav">3.1.5 Wiederverwendbarkeit von Views</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline" colspan="2"><strong><a href="apps_03_002.html#dodtp48e66c8d-0135-4d4a-aca0-154c1cb50ec2" class="navh">3.2 Views und Viewcontroller</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_002.html#dodtpac25936e-a3e5-4cd8-9cec-8686f92f9ec6" class="navh">3.2.1 Outlets</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_002.html#dodtpaac41390-9135-4fdc-a7cf-3867becf384f" class="navh">3.2.2 View-Hierarchien</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_002.html#dodtpfd3f33d1-3da7-47db-b0ae-e871a076e662" class="navh">3.2.3 Actions</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_002.html#dodtp1b1bb933-3bdc-4810-80ac-9f5c2d8a24f6" class="navh">3.2.4 Ereignisse</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_002.html#dodtp009b4d3a-a199-4df6-bd87-5e229a18375d" class="navh">3.2.5 Controlzustände und Buttons</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_002.html#dodtp3a191257-4e08-4274-8b17-625b0208638b" class="navh">3.2.6 Direkte Gestenverarbeitung</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_002.html#dodtpbc46c62d-db40-4709-8cbc-4580da56485f" class="navh">3.2.7 Übergänge</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_002.html#dodtp197deaea-4bd9-433f-a357-f8ab4a157ca6" class="navh">3.2.8 Der Lebenszyklus eines Viewcontrollers</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline" colspan="2"><strong><a href="apps_03_003.html#dodtpf5e69a2b-44b9-48a6-a838-4e601f65ad94" class="navnav">3.3 Lokale Benachrichtigungen</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_003.html#dodtpbc9c4dcc-43e5-44ba-8796-5377ec7cb186" class="navnav">3.3.1 Benachrichtigungen versenden ...</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_003.html#dodtp25696055-745a-4da7-9928-2073c9f44118" class="navnav">3.3.2 ... und verarbeiten</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline" colspan="2"><strong><a href="apps_03_004.html#dodtp1cb56bf3-2314-4800-af45-0afb535fe169" class="navnav">3.4 Eine App für alle</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_004.html#dodtpba7535e2-bc44-4bbb-9a46-60d6cceeb3ab" class="navnav">3.4.1 Das Retina Display</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_004.html#dodtpa4f42412-62c6-40ba-8535-93b28d74b78f" class="navnav">3.4.2 Sprachkursus für die App</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_004.html#dodtpe767cf6c-709f-4b47-aff6-e36e2d4aa28f" class="navnav">3.4.3 Es funktioniert nicht</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_004.html#dodtp30997de2-120c-4188-aaec-a97e12d03cec" class="navnav">3.4.4 Universelle Apps</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline" colspan="2"><strong><a href="apps_03_005.html#dodtp328a43f6-1580-4d6a-8363-0c13dc2738f9" class="navnav">3.5 Fehlersuche</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_005.html#dodtp3ca11770-99b5-4828-b3ac-9236ca7131bf" class="navnav">3.5.1 Logging</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_005.html#dodtp7fa3f986-d0d3-4f84-9220-484085a6f5bf" class="navnav">3.5.2 Der Debugger</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_005.html#dodtp9cead0f4-c431-4b34-9007-c85b3d3dfe9d" class="navnav">3.5.3 Laufzeitfehler</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline" colspan="2"><strong><a href="apps_03_006.html#dodtpcaac84af-76af-4c19-a4cd-176b1c601791" class="navnav">3.6 Die App auf einem Gerät testen</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_006.html#dodtp0c573092-1c85-428a-a49d-0c701eb0a61b" class="navnav">3.6.1 Das iOS Developer Program</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_006.html#dodtp8c4daf78-a061-43aa-b100-d8cfa95f0e06" class="navnav">3.6.2 Entwicklungszertifikat und Entwicklungsprofile</a></strong></td>
                                                   </tr>
                                                   <tr>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"></td>
                                                      <td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
                                                      <td valign="baseline"><strong><a href="apps_03_006.html#dodtp804bfb38-27ef-4215-a13f-204f5283c0e2" class="navnav">3.6.3 Profilprobleme</a></strong></td>
                                                   </tr>
                                                </tbody>
                                             </table>
                                          </td>
                                       </tr>
                                    </tbody>
                                 </table>
                                 <table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
                                    <tbody>
                                       <tr>
                                          <td>
                                             <div class="main"><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtp48e66c8d-0135-4d4a-aca0-154c1cb50ec2" name="dodtp48e66c8d-0135-4d4a-aca0-154c1cb50ec2"></a><h2 class="t2"><span class="cfett">3.2</span><span class="cfett"> Views und Viewcontroller</span><a href="#dodtpac25936e-a3e5-4cd8-9cec-8686f92f9ec6"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a></h2>
                                                <p>Das Beispielprogramm <span class="cdateipfad">Clock</span><a class="indexterm" id="dodtp073ac96f-783c-4759-bf24-14eef911c493"></a>, das sich ebenfalls auf der DVD befindet, zeigt zwar mehrere Uhren an, deren Zeiger
                                                   bleiben aber stehen. Das liegt daran, dass dieses Programm die Methode <span class="clisting">startAnimation</span> nicht aufruft. Wenn Sie diesen Aufruf in die Methode <span class="clisting">awakeFromNib</span> in der Klasse <span class="clisting">ClockView</span> einfügen, bewegen sich die Zeiger. Allerdings startet dann das Laden des Views die
                                                   Timer, und erst der Aufruf der Methode <span class="clisting">dealloc</span> der Uhren stoppt sie. Die Uhren laufen also ständig. Bei so einer kleinen App, die
                                                   nur eine Ansicht zeigt, ist das zwar nicht schlimm. In größeren Projekten ist es sicherlich
                                                   sinnvoller, die Timer nur dann laufen zu lassen, wenn die App sie auch tatsächlich
                                                   anzeigt. Die Klasse <span class="clisting">UIView</span> bietet dafür aber leider keine entsprechenden Methoden an.
                                                </p>
                                                <p>Diese Aufgabe kann der Viewcontroller<a class="indexterm" id="dodtp071aee61-2466-441e-b775-1dd89338f188"></a> übernehmen. In Cocoa Touch leiten sich die Viewcontroller von der Klasse <span class="clisting">UIViewController</span><a class="indexterm" id="dodtp138b96b9-0cae-4106-8d10-103f1232fd91"></a> ab. Diese bietet vier Methoden an, die bei einer Änderung des Anzeigezustandes aufgerufen
                                                   werden und die Sie in Ihren Unterklassen überschreiben können.
                                                </p>
                                                <div class="listing"><pre class="prettyprint">-(void)viewWillAppear:(BOOL)inAnimated;<br>-(void)viewDidAppear:(BOOL)inAnimated;<br>-(void)viewWillDisappear:(BOOL)inAnimated;<br>-(void)viewDidDisappear:(BOOL)inAnimated;<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.19   </strong>Benachrichtigungsfunktionen für die Anzeige des Views
                                                </p>
                                                <p>Während Cocoa Touch die ersten beiden Methoden bei der Anzeige des Views aufruft,
                                                   ruft es die letzten beiden beim Verschwinden des Views auf. Der Namensbestandteil
                                                   <span class="cbegriff">Will</span> bedeutet, dass die Methode vor dem Ereignis aufgerufen wird, während <span class="cbegriff">Did</span> bedeutet, dass sie nach dem Ereignis aufgerufen wird. Der boolesche Parameter gibt
                                                   dabei jeweils an, ob die Anzeige oder das Verschwinden animiert erfolgt. Wenn Sie
                                                   diese Methoden überschreiben, müssen Sie auch immer die entsprechende Methode in der
                                                   Oberklasse aufrufen.
                                                </p>
                                                <p>Sie könnten jetzt also die Uhren in <span class="clisting">viewDidAppear:</span><a class="indexterm" id="dodtp848a8d7e-62c9-42ba-9f0b-113bc726f865"></a> starten und in <span class="clisting">viewWillDisappear:</span><a class="indexterm" id="dodtp842b0e05-9f5e-4620-9b31-7cee208fc198"></a> stoppen. Sie müssen dazu nur noch Ihren Viewcontroller mit den Uhren bekannt machen.
                                                </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtpac25936e-a3e5-4cd8-9cec-8686f92f9ec6" name="dodtpac25936e-a3e5-4cd8-9cec-8686f92f9ec6"></a><h3 class="t3"><span class="cfett">3.2.1</span><span class="cfett"> Outlets</span><a href="#dodtpaac41390-9135-4fdc-a7cf-3867becf384f"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#dodtp48e66c8d-0135-4d4a-aca0-154c1cb50ec2"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
                                                <p>Sie können in NIB-Dateien nicht nur den View-Aufbau speichern, sondern auch Verbindungen
                                                   zwischen den Objekten im NIB und dem <span class="cbegriff">Eigentümer</span> der NIB-Datei<a class="indexterm" id="dodtpe60e0f56-c90f-4969-aa4b-76b2b9e73082"></a>. Der Eigentümer ist dabei das Objekt, das die Datei geöffnet hat. Das ist in der
                                                   Regel der Viewcontroller. Es gibt vier Verbindungstypen:
                                                </p>
                                                <ol class="paufz">
                                                   <li><span class="cbegriff">Actions</span><a class="indexterm" id="dodtp83cdd883-31b4-477c-a95c-081492b13861"></a> sind Verbindungen zwischen Views, die Ereignisse versenden, und Methoden, die diese
                                                      Ereignisse verarbeiten. Dieser Verbindungstyp ist Gegenstand des Abschnitts 3.2.3.
                                                   </li>
                                                   <li>Ein <span class="cbegriff">Outlet</span><a class="indexterm" id="dodtpf0f0596d-ec24-4fa5-97e5-e0716d1318ba"></a> verbindet ein Objekt in der NIB-Datei mit einem Attribut oder einer Property eines
                                                      anderen Objekts.
                                                   </li>
                                                   <li>Eine <span class="cbegriff">Outlet-Collection</span><a class="indexterm" id="dodtp76bd096d-8ecd-40f0-ac14-56eca87ffcdd"></a> verbindet mehrere Objekte mit einem Array-Attribut oder einer Array-Property. Diesen
                                                      Verbindungstyp gibt es erst seit iOS 4.0.
                                                   </li>
                                                   <li>Ein <span class="cbegriff">Segue</span><a class="indexterm" id="dodtpe5082506-47b5-430c-9a6e-6c680ad0fe60"></a> (<span class="cbegriff">Übergang</span>) verbindet in einem Storyboard unter iOS 5 Views, die Ereignisse versenden, mit einem
                                                      Viewcontroller. Übergänge beschreibt Abschnitt 3.2.7.
                                                   </li>
                                                </ol>
                                                <p>Diese Verbindungen erzeugen Sie über den Interface Builder. Kopieren Sie dazu das
                                                   Beispielprojekt <span class="cdateipfad">Clock</span> auf Ihre Festplatte, und öffnen Sie es mit Xcode 4. Wählen Sie danach die Datei <span class="cdateipfad">ClockViewController.xib</span> aus und darin den Hauptview, wie Sie es bereits in Abschnitt 3.1. gemacht haben.
                                                   Wenn Sie jetzt mit der rechten Maustaste (oder mit der linken bei gedrückter <span class="ctastatur"><img align="top" src="keys/ctastatur_KENUUkwp.gif" alt="CTRL" title="CTRL"></span>-Taste) in einen der Clockviews klicken, können Sie eine Verbindung von dem View zu
                                                   der Headerdatei des Controllers ziehen. Dazu müssen Sie im Abschnitt <span class="cscreenelement">Editor</span> der Xcode-Toolbar den <span class="cscreenelement">Assistant Editor</span> aktiviert haben (siehe Abbildung 3.13).
                                                </p><a href="bilder/03_013.png" rel="lightbox" title="Ziehen einer Outlet-Verbindung"><img class="bild" border="1" src="bilderklein/klein03_013.png" alt="Abbildung"></a><p class="pbildunter"><strong>Abbildung 3.13   </strong>Ziehen einer Outlet-Verbindung
                                                </p>
                                                <p>Nachdem Sie die Maustaste innerhalb der Klassendeklaration losgelassen haben, erscheint
                                                   ein Popoverdialog (siehe Abbildung 3.14), über den Sie ein Outlet oder eine Outlet-Collection
                                                   anlegen können. Geben Sie <span class="clisting">clockView</span> in das Textfeld ein, und lassen Sie die übrigen Einstellungen des Dialogs unverändert.
                                                </p><a href="bilder/03_014.png" rel="lightbox" title="Popoverdialog für das Outlet"><img class="bild" border="1" src="bilderklein/klein03_014.png" alt="Abbildung"></a><p class="pbildunter"><strong>Abbildung 3.14   </strong>Popoverdialog für das Outlet
                                                </p>
                                                <p>Durch einen Klick auf den Button <span class="cscreenelement">Connect</span> erstellen Sie im Quelltext ein Attribut und eine Property, vor deren Klasse die Markierung
                                                   <span class="clisting">IBOutlet</span><a class="indexterm" id="dodtp8963626c-0767-4d8c-8e1b-4247a7df946b"></a> steht. Diese Markierung ist ein leeres C-Makro, das keine Auswirkung auf den erzeugten
                                                   Programmcode hat. Es dient lediglich dazu, dem Interface Builder anzuzeigen, dass
                                                   er zu dieser Property Verbindungen herstellen kann.
                                                </p>
                                                <div class="listing"><pre class="prettyprint">@property (nonatomic, retain) IBOutlet ClockView *clockView;<br></pre></div>
                                                <p>Der Speicherverwaltungstyp der Property hängt davon ab, welches Speicherverwaltungsmodell
                                                   Ihr Projekt verwendet. Bei manuellem Referenzenzählen hat die Property den Typ <span class="clisting">retain</span>, und bei automatischem Referenzenzählen hat sie den Typ <span class="clisting">strong</span>.
                                                </p>
                                                <table width="100%" border="0" cellspacing="1" cellpadding="3">
                                                   <tbody>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellenkopf"><span class="cfett">
                                                               
                                                               
                                                               
                                                               Hilfe bei der Speicherverwaltung
                                                               
                                                               </span></td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext">
                                                            <p>Xcode verändert nicht nur die Deklaration Ihrer Klasse, sondern auch deren Implementierung.
                                                               Wenn Sie eine Outlet-Property anlegen, setzt Xcode in der Methode <span class="clisting">viewDidUnload</span> die Property auf <span class="clisting">nil</span>. Wenn Sie in Ihrem Projekt manuelles Referenzenzählen verwenden, sendet Xcode in
                                                               <span class="clisting">dealloc</span> außerdem noch ein <span class="clisting">release</span> an das Attribut.
                                                               
                                                               
                                                            </p>
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                   </tbody>
                                                </table>
                                                <p>Anstelle von Outlet-Propertys<a class="indexterm" id="dodtp32b511e3-1a3f-461e-a46f-587b013e9f6e"></a> können Sie auch Outlet-Attribute<a class="indexterm" id="dodtp38e1ac76-839e-483e-a46d-01430aedff51"></a> erzeugen. Dazu müssen Sie das Gummiband in den Attributblock, also zwischen die geschweiften
                                                   Klammern, der Klassendeklaration ziehen. Allerdings halten sich Outlet-Attribute nicht
                                                   an die Speicherverwaltungsregeln<a class="indexterm" id="dodtpeda60b1a-0c25-46fc-8284-30e878018dd5"></a>. Ein Outlet-Attribut bekommt ein <span class="clisting">retain</span> gesendet, wenn es keinen Setter dafür gibt. Verwenden Sie also auch hier lieber Propertys
                                                   als Attribute.
                                                </p>
                                                <p>Nach dem Laden der NIB-Datei verbindet Cocoa Touch diese Property mit dem View. Sie
                                                   können sich die gesetzten und möglichen Verbindungen eines Objekts im Interface Builder
                                                   über den Verbindungsinspektor<a class="indexterm" id="dodtpe1fc5110-87fc-4e96-a0e5-461487138745"></a> ansehen (siehe Abbildung 3.15).
                                                </p><a href="bilder/03_015.png" rel="lightbox" title="Der Verbindungsinspektor zeigt Verbindungen an."><img class="bild" border="1" src="bilderklein/klein03_015.png" alt="Abbildung"></a><p class="pbildunter"><strong>Abbildung 3.15   </strong>Der Verbindungsinspektor zeigt Verbindungen an.
                                                </p>
                                                <p>Indem Sie die entsprechenden Anweisungen in die Methoden <span class="clisting">viewDidAppear:</span> und <span class="clisting">viewWillDisappear:</span> einfügen, können Sie über den Viewcontroller jetzt eine Uhr starten. Die kompletten
                                                   Methoden müssen Sie in die Implementierungsdatei <span class="cdateipfad">ClockViewController.m</span> schreiben:
                                                </p>
                                                <div class="listing"><pre class="prettyprint">- (void)viewDidAppear:(BOOL)inAnimated {<br>    [super viewDidAppear:inAnimated];<br>    [self.clockView startAnimation];<br>}<br>- (void)viewWillDisappear:(BOOL)inAnimated {<br>    [self.clockView stopAnimation];<br>    [super viewWillDisappear:inAnimated];<br>}<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.20   </strong>Starten und Stoppen der Animation über den Viewcontroller
                                                </p>
                                                <p>Außerdem sollten Sie die Headerdatei der Klasse <span class="clisting">ClockView</span> in diese Implementierungsdatei einbinden, da Sie ansonsten Warnungen bei der Übersetzung
                                                   erhalten. Dazu fügen Sie noch die Zeile
                                                </p>
                                                <div class="listing"><pre class="prettyprint">#import "ClockView.h"<br></pre></div>
                                                <p>in die Implementierungsdatei ein. Setzen Sie sie unter die bereits enthaltene Importanweisung.</p>
                                                <p>Wenn Sie jetzt Ihr Programm im Simulator ausführen, bewegen sich die Zeiger einer
                                                   Uhr, während die anderen Uhren stillstehen. Falls Sie eine andere Uhr aktivieren möchten,
                                                   können Sie einfach ein Gummiband von einem anderen Clockview auf das Outlet ziehen.
                                                   Sie können jetzt für jede Uhr auch ein eigenes Outlet mit den entsprechenden Start-
                                                   und Stoppanweisungen anlegen, um die Uhren analog zu starten und zu stoppen. Das ist
                                                   aber sehr unelegant und sieht nicht sehr schön aus, da Sie mehrmals die gleichen Anweisungen
                                                   schreiben müssen. Für das mehrfache Ausführen der gleichen Anweisung gibt es doch
                                                   schließlich Schleifen.
                                                </p>
                                                <p>Seit iOS 4 können Sie Outlet-Collections<a class="indexterm" id="dodtp2bf9590b-10b6-40da-ab7c-48fed0bd89d7"></a> verwenden, um mehrere Uhren zu verwalten. In früheren iOS-Versionen haben Sie diese
                                                   Möglichkeit allerdings noch nicht. Hier können Sie aber Ihre Uhren über einen Container-View
                                                   verwalten.
                                                </p>
                                                <p>Legen Sie eine neue Kopie des Clock-Beispielprojekts an, öffnen Sie den View wie zu
                                                   Beginn dieses Abschnitts, und ziehen Sie ein Band von einem Clockview in die Schnittstelle
                                                   der Klasse <span class="clisting">ClockViewController</span>. Lassen Sie wieder die Maustaste los, wenn sich der Mauszeiger zwischen der schließenden,
                                                   geschweiften Klammer und dem Schlüsselwort <span class="clisting">@end</span> befindet.
                                                </p>
                                                <p>Im Popoverdialog wählen Sie unter <span class="cscreenelement">Connection</span> jetzt den Punkt <span class="cscreenelement">Outlet Collection</span> aus, und in das Textfeld schreiben Sie <span class="clisting">clockViews</span>. Nach einem Klick auf den <span class="cscreenelement">Connect</span>-Button wird eine Property mit dem Typ <span class="clisting">NSArray</span> angelegt und eine Markierung <span class="clisting">IBOutletCollection(ClockView)</span><a class="indexterm" id="dodtpf9ee331b-2d6c-4adf-9490-a9a43e116691"></a> vor der Deklaration des Typs. Außerdem hat Xcode ein Attribut <span class="clisting">clockViews</span> angelegt und auch die Implementierungsdatei verändert.
                                                </p>
                                                <p>Sie können jetzt der Outlet-Collection beliebig viele Clockviews zuweisen, indem Sie
                                                   Gummibänder von den Views zu dieser Property-Deklaration ziehen. Der Makroparameter
                                                   <span class="clisting">ClockView</span> schränkt im Interface Builder die möglichen Objekte für die Zuweisung auf die Klasse
                                                   <span class="clisting">ClockView</span> ein. Zum Starten und Stoppen der Uhren können Sie jetzt eine Schleife verwenden:
                                                </p>
                                                <div class="listing"><pre class="prettyprint">- (void)viewDidAppear:(BOOL)inAnimated {<br>    [super viewDidAppear:inAnimated];<br>    for(ClockView *theView in self.clockViews) {<br>        [theView startAnimation];<br>    }<br>}<br>- (void)viewWillDisappear:(BOOL)inAnimated {<br>    for(ClockView *theView in self.clockViews) {<br>        [theView stopAnimation];<br>    }<br>    [super viewWillDisappear:inAnimated];<br>}<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.21   </strong>Starten und Stoppen der Uhren über eine Outlet-Collection
                                                </p>
                                                <table width="100%" border="0" cellspacing="1" cellpadding="3">
                                                   <tbody>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellenkopf"><span class="cfett">
                                                               
                                                               
                                                               
                                                               Achtung
                                                               
                                                               </span></td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext">
                                                            <p>Outlet-Collections verwenden zwar Arrays. Sie können aber die Reihenfolge der Elemente
                                                               in dem Array nicht durch den Interface Builder festlegen.
                                                               
                                                               
                                                            </p>
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                   </tbody>
                                                </table><a id="dodtp8d5617b9-5392-40ad-b6fe-d8339d79fc14" name="dodtp8d5617b9-5392-40ad-b6fe-d8339d79fc14"></a><h4 class="t4"><span class="cfett"></span><span class="cfett"> Speicherverwaltung und Outlets</span></h4>
                                                <p>Für Objekte, die Cocoa Touch aus NIB-Dateien lädt und einem Outlet zuweist, gibt es
                                                   eine besondere Speicherverwaltungsregel. Ein solches Objekt empfängt ein zusätzliches
                                                   <span class="clisting">retain</span>, wenn es keine Methode zum Setzen des Wertes gibt. Andernfalls bekommt das Objekt
                                                   kein <span class="clisting">retain</span> geschickt. Sie müssen also Outlet-Attribute<a class="indexterm" id="dodtpc48b7f5c-39b2-4350-8641-cc69349c3020"></a> freigeben, indem Sie ihnen ein <span class="clisting">release</span> schicken. Das sollten Sie in den Methoden <span class="clisting">dealloc</span> und <span class="clisting">viewDidUnload</span><a class="indexterm" id="dodtp8ac9ae49-ba1e-4af0-812d-d94091c5698a"></a> machen, wo Sie danach das Attribut auch noch auf <span class="clisting">nil</span> setzen müssen.
                                                </p>
                                                <table width="100%" border="0" cellspacing="1" cellpadding="3">
                                                   <tbody>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellenkopf"><span class="cfett">
                                                               
                                                               
                                                               
                                                               Tipp
                                                               
                                                               </span></td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext">
                                                            <p>Verwenden Sie für Outlet-Collections und Outlets auf die Elemente in der obersten
                                                               Ebene der NIB-Datei möglichst immer haltende Propertys. Outlets auf Subviews brauchen
                                                               ihren View nicht zu halten, weil das ja deren Superview bereits macht. Verwenden Sie
                                                               aber hier am besten eine Property mit dem Speicherverwaltungstyp <span class="clisting">strong</span> beziehungsweise <span class="clisting">retain</span>.
                                                               <br><br>
                                                               Sie sollten alle Outlets und Outlet-Collections in der Methode <span class="clisting">viewDidUnload</span><a class="indexterm" id="dodtp39fca5a4-0e11-4812-919c-dabe2ef4192f"></a> (siehe Abschnitt 3.2.7) &#8211; und bei manueller Speicherverwaltung auch in <span class="clisting">dealloc</span> &#8211; freigeben und am besten auch auf <span class="clisting">nil</span> setzen.
                                                               <br><br>
                                                               Am einfachsten geht das über einen Setter-Aufruf mit dem Wert <span class="clisting">nil</span>. Die Beispielprogramme verwenden ausschließlich Propertys.
                                                               
                                                               
                                                            </p>
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      
                                                      
                                                      
                                                      
                                                   </tbody>
                                                </table>
                                                <p>Seit Xcode 4 gibt es diese Möglichkeit, die Verbindungen von den Views direkt in den
                                                   Header des Controllers zu ziehen. In älteren Versionen war das nicht möglich, und
                                                   der Controller wurde durch ein Symbol dargestellt. Dieses Symbol finden Sie auch immer
                                                   noch in der aktuellen Version des Interface Builders. Es ist der <span class="cscreenelement">File&#8217;s Owner</span><a class="indexterm" id="dodtp5bd5be6a-8c1c-4b62-8107-8ba2c72cbe35"></a>, der gelbe Würfel, links neben ihrem View. Dieses Objekt ist nur ein Platzhalter
                                                   für ein Objekt, das aber nicht in der NIB-Datei enthalten ist. Wenn der Viewcontroller
                                                   die NIB-Datei über die Methode <span class="clisting">loadView</span> lädt, ist der File&#8217;s Owner der Viewcontroller. Für die Datei <span class="cdateipfad">MainWindow.nib</span><a class="indexterm" id="dodtp49023f12-ab2d-48b1-a7c0-2f49d0033424"></a>, auf die wir später noch eingehen, ist es hingegen das Singleton <span class="clisting">UIApplication</span><a class="indexterm" id="dodtpaa30284d-11e9-4f22-9b2b-cdca765b708d"></a>. Wenn Sie allerdings eine NIB-Datei manuell laden, können Sie jedes beliebige Objekt
                                                   als Eigentümer verwenden.
                                                </p><a id="dodtpc0fedf26-b8f6-4d47-ab58-bb7cb1f07be0" name="dodtpc0fedf26-b8f6-4d47-ab58-bb7cb1f07be0"></a><h4 class="t4"><span class="cfett"></span><span class="cfett"> Containerviews</span></h4>
                                                <p>Wenn Sie mit Ihrer App eine ältere iOS-Version als 4 unterstützen möchten oder die
                                                   Reihenfolge der Views wichtig ist, können Sie statt der Outlet-Collection auch einen
                                                   View als Container verwenden. Sie legen dazu alle Views, auf die Sie gesammelt zugreifen
                                                   möchten, in einem gemeinsamen View an. Auf diesen View greifen Sie über ein Outlet
                                                   zu. Häufig wird für diese <span class="cbegriff">Containerviews</span><a class="indexterm" id="dodtp91b84c97-262e-4e62-81ca-a79de68192b1"></a> ein <span class="clisting">UIView</span> mit transparenter Hintergrundfarbe verwendet. An die einzelnen Views gelangen Sie
                                                   dann über die Property <span class="clisting">subviews</span> des Containerviews. Allerdings kann jeder View nur in maximal einem Containerview
                                                   liegen.
                                                </p>
                                                <table width="100%" border="0" cellspacing="1" cellpadding="3">
                                                   <tbody>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellenkopf"><span class="cfett">
                                                               
                                                               
                                                               
                                                               Unterstützung älterer iOS-Versionen
                                                               
                                                               </span></td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext">
                                                            <p>Programmierer neigen dazu, immer die aktuelle Version des Betriebssystems vorauszusetzen.
                                                               Bei den Endanwendern sieht das allerdings anders aus. Apple unterstützt iOS 4 und
                                                               erst recht iOS 5 nicht oder nur eingeschränkt auf älteren iPhones und iPod touches.
                                                               Besitzer eines iPhone 2G müssen mit iOS 3 vorliebnehmen, und iOS 5 läuft nicht mehr
                                                               auf einem 3G. Mit zunehmender Vielfalt von Cocoa-Touch-Geräten ist damit zu rechnen,
                                                               dass es immer eine nicht zu kleine Benutzergruppe gibt, die nicht die aktuelle Version
                                                               von iOS verwenden kann.
                                                               <br><br>
                                                               Überlegen Sie daher vor der Verwendung neuer Features wie den Outlet-Collections,
                                                               welche Reichweite Ihre App haben soll. Falls die App bezüglich der Hardware-Ressourcen
                                                               sehr anspruchsvoll ist oder wenn sie Funktionen benötigt, die erst ab iOS 4 zur Verfügung
                                                               stehen, ist die Unterstützung älterer Geräte nicht notwendig. Bei einer App ohne besondere
                                                               Hardware-Anforderungen lässt sich der Kreis der potenziellen Benutzer aber allein
                                                               dadurch vergrößern, dass die App auf allen möglichen Geräten läuft &#8211; auch wenn das
                                                               bedeutet, dass Sie nicht alle Annehmlichkeiten der neueren iOS-Versionen verwenden
                                                               können.
                                                               
                                                               
                                                            </p>
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      
                                                      
                                                   </tbody>
                                                </table>
                                                <p>In unserem Beispielprojekt existiert bereits ein View, den Sie als Containerview verwenden
                                                   können. Es ist der Hauptview, in den Sie alle Clockviews gelegt haben. Für diesen
                                                   Containerview brauchen Sie kein Outlet, da er bereits durch eine Property mit dem
                                                   Viewcontroller verbunden ist. Sie können also die Outlet-Collection im letzten Listing
                                                   durch die Property <span class="clisting">subviews</span> der <span class="clisting">view</span>-Property des Viewcontrollers ersetzen. Sie müssen dazu nur die Zeilen mit den Schleifenköpfen
                                                   durch
                                                </p>
                                                <div class="listing"><pre class="prettyprint">for(ClockView *theView in self.view.subviews) {<br></pre></div>
                                                <p>ersetzen. Das funktioniert aber nur solange, wie Sie keine Views einer anderen Klasse
                                                   in den Hauptview legen.
                                                </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtpaac41390-9135-4fdc-a7cf-3867becf384f" name="dodtpaac41390-9135-4fdc-a7cf-3867becf384f"></a><h3 class="t3"><span class="cfett">3.2.2</span><span class="cfett"> View-Hierarchien</span><a href="#dodtpfd3f33d1-3da7-47db-b0ae-e871a076e662"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#dodtpc0fedf26-b8f6-4d47-ab58-bb7cb1f07be0"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
                                                <p>Die Reihenfolge der Subviews im darüber liegenden View ist entscheidend für die Anzeige.
                                                   Sie können sich die Reihenfolge in der Baumdarstellung des Views ansehen, zu der Sie
                                                   gelangen, indem Sie auf das Symbol am unteren Fensterrand von Xcode 4 klicken (siehe
                                                   den Mauszeiger in Abbildung 3.16).
                                                </p><a href="bilder/03_016.png" rel="lightbox" title="Umstellung auf Baumansicht (Mauszeiger)"><img class="bild" border="1" src="bilderklein/klein03_016.png" alt="Abbildung"></a><p class="pbildunter"><strong>Abbildung 3.16   </strong>Umstellung auf Baumansicht (Mauszeiger)
                                                </p>
                                                <p>In der Baumdarstellung<a class="indexterm" id="dodtpba965734-3615-4bae-bb4d-ba910d55c67f"></a> können Sie sehen, wie die Views verschachtelt sind und in welcher Reihenfolge sie
                                                   innerhalb einer Ebene liegen. Diese Anordnung wirkt sich auf die Darstellung und die
                                                   Verarbeitung der Eingaben (oder auch <span class="ckursiv">Touches</span>) aus. Je näher ein View zum Hauptview liegt, umso früher stellt Cocoa Touch ihn dar.
                                                   Wenn also zwei Views einen gleichen Bereich auf dem Display verwenden, dann verdeckt
                                                   der später dargestellte View den früher dargestellten.
                                                </p>
                                                <p>In Abbildung 3.17 ist die Baumdarstellung eines Views zu sehen. Dabei haben die  Views
                                                   (1 bis 8) jeweils die gleichen Ziffern wie die Views in der Voransicht. Der rote View 2 ist am nächsten zum Hauptview, weswegen ihn alle anderen Views verdecken. Der gelbe
                                                   View 6 liegt hinter dem grünen 3 und verdeckt somit diesen. Der schwarze View 7 liegt im gelben View, wodurch er diesen verdeckt.
                                                </p>
                                                <table width="100%" border="0" cellspacing="1" cellpadding="3">
                                                   <tbody>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellenkopf"><span class="cfett">
                                                               
                                                               
                                                               
                                                               Änderung der Viewhierarchie<a class="indexterm" id="dodtpb2686d2e-e487-4e14-bf24-6ebda78dd4be"></a>
                                                               
                                                               </span></td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext">
                                                            <p>Sie können auch in der Baumdarstellung die Anordnung der Views verändern. Ziehen Sie
                                                               dazu die Views einfach an die gewünschte Position. Wenn Sie dort einen View auf einen
                                                               anderen ziehen, fügt der Interface Builder den gezogenen View als letzten Subview
                                                               des anderen Views ein.
                                                               
                                                               
                                                            </p>
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                   </tbody>
                                                </table><a href="bilder/03_017.png" rel="lightbox" title="Baumdarstellung eines Views"><img class="bild" border="1" src="bilderklein/klein03_017.png" alt="Abbildung"></a><p class="pbildunter"><strong>Abbildung 3.17   </strong>Baumdarstellung eines Views
                                                </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtpfd3f33d1-3da7-47db-b0ae-e871a076e662" name="dodtpfd3f33d1-3da7-47db-b0ae-e871a076e662"></a><h3 class="t3"><span class="cfett">3.2.3</span><span class="cfett"> Actions</span><a href="#dodtp1b1bb933-3bdc-4810-80ac-9f5c2d8a24f6"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#dodtpaac41390-9135-4fdc-a7cf-3867becf384f"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
                                                <p>Bislang haben die verwendeten Views nur etwas auf dem Bildschirm dargestellt. Viele
                                                   Views können aber auch Eingaben verarbeiten. Im Gegensatz zu den meisten Desktop-Computern
                                                   ist bei iOS-Geräten das Ausgabegerät ja auch gleichzeitig das Eingabegerät. Diese
                                                   Views sind in der Regel von der Klasse <span class="clisting">UIControl</span><a class="indexterm" id="dodtp6555d89d-26a5-4435-be08-1c43c64333d1"></a> abgeleitet und werden im Folgenden auch kurz als <span class="cbegriff">Controls</span><a class="indexterm" id="dodtp9977b425-18df-4f4f-a15c-49f4b1b2daa3"></a> bezeichnet. Typische Controls sind beispielsweise Buttons, Schieberegler und Textfelder.
                                                </p>
                                                <p>Neben den Outlets können Sie auch Action-Verbindungen herstellen. Mit diesen Verbindungen
                                                   verknüpfen Sie die von den Controls gesendeten Ereignisse mit einer Methode eines
                                                   Controllers. Wenn Sie eine Action-Verbindung zu einem Control erzeugen, bekommt das
                                                   Control ein Zielobjekt und eine Action-Methode<a class="indexterm" id="dodtpadabd924-b02b-4c9d-a49c-3967cfb7c7a6"></a> übergeben. Dieses Vorgehen bezeichnet man auch als <span class="cbegriff">Target-Action-Mechanismus</span><a class="indexterm" id="dodtpf6c8db3c-7357-41cc-846a-72b509a8026e"></a>.
                                                </p>
                                                <p>Action-Methoden müssen eine von drei vorgegebenen Signaturen haben und zumindest in
                                                   der Deklaration für den Rückgabetyp das Makro <span class="clisting">IBAction</span><a class="indexterm" id="dodtp70a86dee-2d5c-4654-9673-3018070a9c3d"></a> verwenden. Dieses Makro wird während der Übersetzung durch den C-Typen <span class="clisting">void</span> ersetzt. Es zeigt dem Interface Builder an, dass es sich bei einer Methode um eine
                                                   Action-Methode handelt.
                                                </p>
                                                <p>Die drei möglichen Signaturen für Action-Methoden sind:</p>
                                                <div class="listing"><pre class="prettyprint">-(IBAction)methodenName;<br>-(IBAction)methodenName:(id)inSender;<br>-(IBAction)methodenName:(id)inSender<br>               forEvent:(UIEvent *)inEvent;<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.22   </strong>Mögliche Signaturen für Action-Methoden
                                                </p>
                                                <p>Den Methodennamen können Sie dabei natürlich frei wählen. Der erste Parameter in der
                                                   zweiten und dritten Variante enthält das Control, das das Ereignis abgeschickt hat.
                                                   Als Typ wurde hier <span class="clisting">id</span> verwendet, der auf jede Klasse passt. Sie dürfen aber auch einen konkreten Typ, beispielsweise
                                                   <span class="clisting">UIButton *</span>, verwenden. Dann können Sie in der Methode auch die Punktnotation für dieses Control
                                                   verwenden.
                                                </p>
                                                <p>Über den Event-Parameter der dritten Variante können Sie zusätzliche Informationen
                                                   über das auslösende Ereignis erhalten. Über den Event<a class="indexterm" id="dodtp207d79ad-e029-4115-8587-4ab582d8b2bf"></a> erhalten Sie beispielsweise die genauen Fingerpositionen zum Auslösezeitpunkt. Die
                                                   liefert Ihnen der Event in Objekten der Klasse <span class="clisting">UITouch</span><a class="indexterm" id="dodtp1bac5c4b-f9bf-4b5c-8a71-3bd1bb05bb54"></a>. Eine Möglichkeit, die Fingerposition<a class="indexterm" id="dodtpac22f1f7-460f-4bd0-a685-51de6a70c1b7"></a> zu bestimmen, stellt Listing 3.23 dar.
                                                </p>
                                                <div class="listing"><pre class="prettyprint">- (IBAction)touchWithSender:(id)inSender<br>                   forEvent:(UIEvent *)inEvent {<br>   UITouch *theTouch = [inEvent.allTouches anyObject];<br>   CGPoint thePoint = [theTouch locationInView:inSender];<br>   // Touchposition in thePoint auswerten<br>}<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.23   </strong>Ermittlung der Touchposition
                                                </p>
                                                <p>Sie sollen jetzt einen Schalter, das ist ein View der Klasse <span class="clisting">UISwitch</span><a class="indexterm" id="dodtp01d4ce42-2fb1-4f03-8664-7b2fe854b501"></a>, dafür verwenden, den Animationsstatus einer Uhr aus dem Clock-Projekt zu steuern.
                                                   Legen Sie dafür wieder eine Kopie dieses Projekts an, löschen Sie die drei kleinen
                                                   Uhren aus dem View, und legen Sie ein Outlet für die verbliebene Uhr an. Als Nächstes
                                                   fügen Sie einen <span class="clisting">UISwitch</span> hinzu. Das ist ein Schiebeschalter mit zwei Zuständen für »an« und »aus«. Nach dem
                                                   Einfügen ziehen Sie von dem Schiebeschalter ein Band in den Header des Viewcontrollers.
                                                   In dem Popoverdialog haben Sie nun eine zusätzliche Auswahlmöglichkeit <span class="cscreenelement">Action</span>. Füllen Sie diesen Dialog wie in Abbildung 3.18 gezeigt aus.
                                                </p><a href="bilder/03_018.png" rel="lightbox" title="Anlegen einer Action-Methode"><img class="bild" border="1" src="bilderklein/klein03_018.png" alt="Abbildung"></a><p class="pbildunter"><strong>Abbildung 3.18   </strong>Anlegen einer Action-Methode
                                                </p>
                                                <p>Das Control sendet das Ereignis <span class="cbegriff">Value Changed</span><a class="indexterm" id="dodtp232c9756-c793-47e6-9b80-55b166384119"></a> immer dann, wenn sich der Wert ändert, den das Control verwaltet. Bei einem <span class="clisting">UISwitch</span> ist das ein boolescher Wert, der die Schalterstellung repräsentiert.
                                                </p>
                                                <p>Sie können nun die Action-Methode wie folgt implementieren:</p>
                                                <div class="listing"><pre class="prettyprint">- (IBAction)switchAnimation:(UISwitch *)inSender {<br>    if(inSender.on) {<br>        [clockView startAnimation];<br>    }<br>    else {<br>        [clockView stopAnimation];<br>    }<br>}<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.24   </strong>Action-Methode zum Starten und Stoppen der Animation
                                                </p>
                                                <p>Außerdem sollte die Methode <span class="clisting">viewWillDisappear:</span> die Uhr stoppen. Wenn Sie nun das Projekt ausführen, können Sie die Uhr über den
                                                   Schalter starten und stoppen. Allerdings wird nach dem Starten die Uhr stehen, obwohl
                                                   der Schalter eingeschaltet ist. Sie können das umgehen, indem Sie entweder die Uhr
                                                   in <span class="clisting">viewDidAppear:</span> starten oder im Attributinspektor des Schalters dessen Anfangszustand ändern.
                                                </p>
                                                <p>Eine andere Möglichkeit besteht darin, auch für den Schalter ein Outlet anzulegen.
                                                   Der Wert des Schalters wird in der Methode <span class="clisting">viewDidAppear:</span> ausgelesen, und in Abhängigkeit davon wird die Uhr gestartet. Der Vorteil dieser
                                                   Lösung ist, dass Sie den Anfangszustand der Uhr über den Interface Builder, also ohne
                                                   Veränderung des Programmcodes, einstellen können. Das ist bei diesem kleinen Projekt
                                                   vielleicht kein so großer Vorteil, kann aber bei sehr umfangreichen und komplexen
                                                   Applikationen sehr angenehm sein. Wenn Sie das entsprechende Outlet <span class="clisting">animationSwitch</span> nennen, sieht der Code dafür so aus:
                                                </p>
                                                <div class="listing"><pre class="prettyprint">-(void)viewDidAppear:(BOOL)inAnimated {<br>    [super viewDidAppear:inAnimated];<br>    if(animationSwitch.on) {<br>        [clockView startAnimation];<br>    }<br>}<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.25   </strong>Starten der Animation in Abhängigkeit von einem Schalter
                                                </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtp1b1bb933-3bdc-4810-80ac-9f5c2d8a24f6" name="dodtp1b1bb933-3bdc-4810-80ac-9f5c2d8a24f6"></a><h3 class="t3"><span class="cfett">3.2.4</span><span class="cfett"> Ereignisse</span><a href="#dodtp009b4d3a-a199-4df6-bd87-5e229a18375d"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#dodtpfd3f33d1-3da7-47db-b0ae-e871a076e662"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
                                                <p>Sie haben im Beispielprogramm das Ereignis<a class="indexterm" id="dodtp354e658c-0e92-4f96-84ca-f352e850b319"></a> <span class="cbegriff">Value Changed</span> von einem Schalter an eine Methode Ihres Viewcontrollers gesendet. Ein Control kann
                                                   noch eine Reihe weiterer Ereignisse senden. Diese Ereignisse lassen sich in drei Kategorien
                                                   unterteilen:
                                                </p>
                                                <ul class="gp">
                                                   <li>Ereignisse für Wertänderungen</li>
                                                   <li>Ereignisse für Gesten</li>
                                                   <li>Ereignisse für Textänderungen</li>
                                                </ul>
                                                <p>Wir untersuchen die einzelnen Ereignisse im Folgenden genauer.</p><a id="dodtpd8b20d0e-32d1-4200-be5b-150c2c8414ca" name="dodtpd8b20d0e-32d1-4200-be5b-150c2c8414ca"></a><h4 class="t4"><span class="cfett"></span><span class="cfett"> Ereignisse für Wertänderungen</span></h4>
                                                <p>Dieses Ereignis haben Sie bereits kennengelernt, und es hat den Typ <span class="clisting">UIControlEventValueChanged</span><a class="indexterm" id="dodtp960b50ca-3f5c-405c-8d88-bc1f4ff2c5e8"></a>. Es wird von Controls gesendet, die einen Wert manipulieren. Dazu gehören die Klassen
                                                   <span class="clisting">UIPageControl</span>, <span class="clisting">UISegmentedControl</span>, <span class="clisting">UISlider</span> und <span class="clisting">UISwitch</span>.
                                                </p><a id="dodtpf7785110-7711-49af-b510-4a11f99c045f" name="dodtpf7785110-7711-49af-b510-4a11f99c045f"></a><h4 class="t4"><span class="cfett"></span><span class="cfett"> Ereignisse für Gesten</span></h4>
                                                <p>Ein wichtiger Erfolgsfaktor des iPhones ist dessen Gestensteuerung. Es gibt in iOS
                                                   zwei Klassen von Gesten. Der Nutzer kann über <span class="cbegriff">Berührungsgesten</span><a class="indexterm" id="dodtpf8fcbca6-8c6d-4ab4-8f23-ab38b5db3ef6"></a> Eingaben auf dem Bildschirm machen. Das können einfache Fingerdrücke oder komplexere
                                                   Mehrfingerbewegungen auf dem Touchscreen sein. Dieser Abschnitt beschäftigt sich ausschließlich
                                                   mit dieser Gestenklasse. Eine weitere grundsätzliche Möglichkeit, Eingaben vorzunehmen,
                                                   sind Bewegungs- und Schüttelgesten, die das fünfte Kapitel behandelt.
                                                </p>
                                                <p>Berührungsgesten lösen eine Reihe von unterschiedlichen Ereignissen aus. Eine Berührungsgeste
                                                   kann sich über mehrere Views erstrecken. Die Ereignisse werden aber immer an das Control
                                                   gesendet, das das erste Ereignis einer Geste empfangen hat.
                                                </p>
                                                <ol class="paufz">
                                                   <li><span class="clisting">UIControlEventTouchDown</span><a class="indexterm" id="dodtp907dfb4c-d1e5-4c0f-9bfe-04a2fa912295"></a> leitet alle Gesten ein und wird bei der ersten Berührung des Controls gesendet.
                                                   </li>
                                                    <p class="peg"><span class="clisting">UIControlEventTouchDownRepeat</span><a class="indexterm" id="dodtp7f14508e-9d36-4876-9694-0e6f2599ca45"></a> wird bei mehreren, schnell aufeinanderfolgenden Berührungen für die Berührungen nach
                                                   <span class="clisting">UIControlEventTouchDown</span> gesendet. Sie können mit diesem Ereignistyp beispielsweise Doppel- oder Dreifachtaps
                                                   auswerten. Die Anzahl der Taps können Sie über die Property <span class="clisting">tapCount</span> aus den <span class="clisting">UITouch</span>-Objekten des Ereignisses erfragen. Die Touch-Objekte erhalten Sie über die Property
                                                   <span class="clisting">allTouches</span> der Klasse <span class="clisting">UIEvent</span> (siehe Listing 3.23).
                                                </p>
                                                   <li><span class="clisting">UIControlEventTouchUpInside</span><a class="indexterm" id="dodtp65ecb204-c33c-4d7e-80b0-f3abae8990de"></a> beendet eine Geste, wenn sich die Finger zuletzt innerhalb des auslösenden Controls befunden haben. Sie verwenden diesen Ereignistyp in der Regel als Auslöser bei Buttons.
                                                   </li>
                                                   <li><span class="clisting">UIControlEventTouchUpOutside</span><a class="indexterm" id="dodtp1246290b-b1d4-42db-aca6-15b2247ef6ca"></a> beendet eine Geste, wenn sich die Finger zuletzt außerhalb des auslösenden Controls befunden haben.
                                                   </li>
                                                   <li><span class="clisting">UIControlEventTouchCancel</span><a class="indexterm" id="dodtp82f8e694-e24a-4cdc-8921-ce5cc50ed6d7"></a> bricht eine Geste ab. Dieser Ereignistyp wird beispielsweise an Controls innerhalb eines Scrollviews gesendet, wenn Cocoa Touch erkennt, dass Sie mit der Geste scrollen möchten und die Ereignisse nicht das Control betreffen. Cocoa Touch sendet dieses Ereignis auch, wenn es die Gestenverarbeitung wegen einer Speicherwarnung abbrechen muss.
                                                   </li>
                                                   <li><span class="clisting">UIControlEventTouchDragInside</span><a class="indexterm" id="dodtp6c3ed69f-3bb5-4c73-80f4-5e7fcf910c24"></a> zeigt eine Fingerbewegung innerhalb eines Controls an.
                                                   </li>
                                                   <li><span class="clisting">UIControlEventTouchDragOutside</span><a class="indexterm" id="dodtpdd9ba6b8-2f7e-4843-9e69-5b5626e7cffd"></a> zeigt eine Fingerbewegung außerhalb eines Controls an.
                                                   </li>
                                                   <li><span class="clisting">UIControlEventTouchDragExit</span><a class="indexterm" id="dodtp78718d5e-6abf-41d6-9896-b6f1b376d7a0"></a> wird gesendet, wenn Sie die Finger aus dem Control heraus bewegen. Dieser Ereignistyp markiert den Übergang von <span class="clisting">UIControlEventTouchDragInside</span> zu <span class="clisting">UIControlEventTouchDragOutside</span>.
                                                   </li>
                                                   <li><span class="clisting">UIControlEventTouchDragEnter</span><a class="indexterm" id="dodtpa142b11e-4984-43d5-bc3e-89d0093c9b3f"></a> wird beim Verschieben der Finger in das Control hinein gesendet. Dieser Ereignistyp markiert den Übergang von <span class="clisting">UIControlEventTouchDragOutside</span> zu <span class="clisting">UIControlEventTouchDragInside</span>.
                                                   </li>                                                
                                                </ol>
                                                   <p>Sie können sich sehr komplexe Gesten ausdenken und mit diesen Ereignistypen umsetzen.
                                                   Allerdings scheinen die von außerhalb des Controls gesendeten Ereignisse nicht so
                                                   zuverlässig zu funktionieren. Es kann beispielsweise vorkommen, dass Sie bei einer
                                                   Fingerverschiebung aus dem Control heraus noch weitere <span class="clisting">UIControlEventTouchDragInside</span>-Ereignisse empfangen. Die Umschaltung auf <span class="clisting">UIControlEventTouchDragOutside</span> erfolgt teilweise erst, wenn sich der Finger schon lange außerhalb des Controls befindet.
                                                   Wenn Sie also diese Ereignistypen verwenden möchten, sollten Sie ausgiebige Tests
                                                   auf Geräten mit einplanen.
                                                </p>
                                                <p>Viele Gesten lassen sich aber relativ einfach umsetzen. Sie können beispielsweise
                                                   Mehrfachtaps mit folgender Action-Methode auswerten, die Sie mit dem Ereignistyp <span class="clisting">UIControlEventTouchDownRepeat</span> verbinden:
                                                </p>
                                                <div class="listing"><pre class="prettyprint">- (IBAction)handleMultiTap:(id)inSender<br>                 forEvent:(UIEvent *)inEvent {<br>    UITouch *theTouch = inEvent.allTouches.anyObject;<br>    if(theTouch.tabCount == 2) {<br>        // Doppel-Tap erkannt<br>    }<br>}<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.26   </strong>Erkennung einer Double-Tap-Geste
                                                </p>
                                                <p>In den Body der If-Abfrage können Sie den Code einsetzen, den Sie bei einem Doppel-Tap<a class="indexterm" id="dodtp3f336eb5-ea95-44ce-8f99-70c14cc60771"></a> ausführen wollen. Die Zahl in der Bedingung gibt die notwendige Anzahl der Taps an.
                                                   Wenn Sie sie entsprechend anpassen, können Sie mit dem Code auch Dreifach- oder Vierfach-Taps
                                                   erkennen.
                                                </p>
                                                <p>Jede Geste sendet mindestens zwei Ereignisse: <span class="clisting">UIControlEventTouchDown</span> und einen Touch-Up-Event. Sie können bei Gesten für Fingerbewegungen <span class="clisting">UIControlEventTouchDown</span> zur Initialisierung der Geste und <span class="clisting">UIControlEventTouchUpInside</span> oder -<span class="clisting">Outside</span> zum Beenden verwenden. Gegebenenfalls sollten Sie auch das Ereignis <span class="clisting">UIControlEventTouchCancel</span> auswerten. Über dieses Ereignis können Sie Änderungen bei einem Gestenabbruch rückgängig
                                                   machen.
                                                </p>
                                                <p>Die Gestenverarbeitung für Ereignisse lässt sich aber nur sehr schlecht wiederverwenden.
                                                   Das ist gerade bei komplexen Gesten ungünstig. Für die Gestenverarbeitung gibt es
                                                   noch andere Möglichkeiten, die dieses Kapitel auch noch vorstellt (siehe Abschnitt
                                                   3.2.6).
                                                </p><a id="dodtp9d76c591-e937-4059-abf4-96970acead2c" name="dodtp9d76c591-e937-4059-abf4-96970acead2c"></a><h4 class="t4"><span class="cfett"></span><span class="cfett"> Ereignisse für Textänderungen</span></h4>
                                                <p>Diese Ereignisse unterstützt derzeit nur die Klasse <span class="clisting">UITextField</span>. Sie können zwar auch hier Action-Methoden mit <span class="clisting">UIEvent</span>-Parametern verwenden. Dafür bekommen Sie hier aber immer <span class="clisting">nil</span> übergeben.
                                                </p>
                                                <ol class="paufz">
                                                   <li><span class="clisting">UIControlEventEditingDidBegin</span><a class="indexterm" id="dodtp43d645f3-412a-4c3e-8390-0470cc1b000e"></a> markiert den Beginn <br>der Eingabe in ein Textfeld.
                                                   </li>
                                                   <li><span class="clisting">UIControlEventEditingDidChange</span><a class="indexterm" id="dodtpb0674a4b-8b84-48c2-ab48-9959c2768621"></a> zeigt die Änderungen <br>des Textes im Textfeld an.
                                                   </li>
                                                   <li><span class="clisting">UIControlEventEditingDidEnd</span><a class="indexterm" id="dodtp71794cba-3878-4399-9877-7b1bffe6834e"></a> markiert das Ende der Eingabe in ein Textfeld.
                                                   </li>
                                                   <li><span class="clisting">UIControlEventEditingDidEndOnExit</span><a class="indexterm" id="dodtp1689e2e8-9f51-48ee-ac8c-a175fb331ada"></a> markiert ebenfalls das Ende der Eingabe in ein Textfeld. Das Textfeld sendet dieses
                                                      Ereignis anscheinend nur, wenn der Nutzer das Textfeld durch Drücken des Return-Knopfes
                                                      über die Systemfunktion beendet. Leider geht die Apple-Dokumentation auf dieses Ereignis
                                                      nicht genauer ein.
                                                   </li>
                                                </ol>
                                                <p>Ein View, dessen Klasse nicht von <span class="clisting">UIControl</span> abgeleitet ist, kann keine Ereignisse verschicken. Wenn Sie aber ein Ereignis senden
                                                   möchten, beispielsweise um die Berührung eines Bildes zu verarbeiten, können Sie das
                                                   Bild einfach in einen View mit der Klasse <span class="clisting">UIControl</span> legen. Sie legen ein solches Control wie einen Clockview an. Ziehen Sie ein Viewobjekt
                                                   an die gewünschte Stelle, und ändern Sie dessen Klasse im Identitätsinspektor auf
                                                   <span class="clisting">UIControl</span>. Im Verbindungsinspektor dieses Views finden Sie dann alle beschriebenen Ereignisse.
                                                </p>
                                                <p>Sie können aber auch einen Button verwenden, der auch die Anzeige von Bildern unterstützt.</p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtp009b4d3a-a199-4df6-bd87-5e229a18375d" name="dodtp009b4d3a-a199-4df6-bd87-5e229a18375d"></a><h3 class="t3"><span class="cfett">3.2.5</span><span class="cfett"> Controlzustände und Buttons</span><a href="#dodtp3a191257-4e08-4274-8b17-625b0208638b"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#dodtp9d76c591-e937-4059-abf4-96970acead2c"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
                                                <p>Neben den Ereignissen unterstützen Controls auch drei boolesche Systemzustände. Diese
                                                   Zustände<a class="indexterm" id="dodtpb2ed98c7-6b1a-470c-8eeb-cc7cb37e0ac9"></a> werden durch eine Bitmaske<a class="indexterm" id="dodtp24d97911-bda4-4d44-a04e-01fa323f6eae"></a> in der Property <span class="clisting">state</span> des Controls abgebildet.
                                                </p>
                                                <ol class="paufz">
                                                   <li><span class="clisting">UIControlStateHighlighted</span><a class="indexterm" id="dodtp38d236a6-6bc4-4570-96fd-644d8c4a1bd5"></a> ist aktiv, solange das Control gedrückt wird. Dieser Zustand kann auch über die Property
                                                      <span class="clisting">highlighted</span> abgefragt oder gesetzt werden.
                                                   </li>
                                                   <li><span class="clisting">UIControlStateDisabled</span><a class="indexterm" id="dodtp4b5c56e9-e8f8-460f-a082-f1bb2e6a66a5"></a> setzt das Control inaktiv. Es verarbeitet keine Eingaben und versendet auch keine
                                                      Ereignisse. Diesen Zustand können Sie auch über die Property <span class="clisting">enabled</span> abfragen oder setzen. Der Wert der Property ist dabei aber genau umgekehrt zu dem
                                                      Wert in der Bitmaske.
                                                   </li>
                                                   <li><span class="clisting">UIControlStateSelected</span><a class="indexterm" id="dodtp93975d09-0a1a-4275-ae64-175adeb681bf"></a> zeigt an, dass das Control ausgewählt ist. Diesen Zustand können Sie auch über die
                                                      Property <span class="clisting">selected</span> abfragen oder setzen.
                                                   </li>
                                                </ol>
                                                <p>Ein Control kann mehrere Zustände gleichzeitig aktiviert haben. Wenn kein Zustand
                                                   in der Bitmaske gesetzt ist, hat das Control den Zustand <span class="clisting">UIControlStateNormal</span>. Am ausgiebigsten machen Buttons von den Zuständen Gebrauch.
                                                </p>
                                                <p>Buttons sind relativ komplexe Controls, die mehrere Darstellungselemente unterstützen.
                                                   Die Darstellungselemente können Sie in Abhängigkeit zu den Zuständen setzen. Sie können
                                                   für jede Zustandskombination eine eigene Darstellung festlegen. Außerdem können Sie
                                                   über die Property <span class="clisting">adjustsImageWhenHighlighted</span> zusätzlich festlegen, dass der Button beim Drücken noch einen Glüheffekt anzeigt.
                                                   Abbildung 3.19 stellt rechts jeweils einen Button im Zustand <span class="clisting">highlighted</span> ohne und mit Glüheffekt dar.
                                                </p><a href="bilder/03_019.png" rel="lightbox" title="Die verschiedenen Darstellungstypen für Buttons"><img class="bild" border="1" src="bilderklein/klein03_019.png" alt="Abbildung"></a><p class="pbildunter"><strong>Abbildung 3.19   </strong>Die verschiedenen Darstellungstypen für Buttons
                                                </p>
                                                <p>Ein Button kann einen von sechs vordefinierten Darstellungstypen haben, wobei fünf
                                                   Typen ein festes Aussehen haben (siehe Abbildung 3.19, links) und Sie beim sechsten
                                                   Typ, <span class="clisting">UIButtonTypeCustom</span>, das Aussehen selbst bestimmen können.
                                                </p>
                                                <p>Ein <span class="cbegriff">Custom-Button</span> unterstützt drei Darstellungselemente: ein Vorder- und ein Hintergrundbild und einen
                                                   Titel (siehe Abbildung 3.20). Für den Titel können Sie außerdem noch die Text- und
                                                   die Schattenfarbe zustandsabhängig setzen. Sie können also über diese fünf Eigenschaften
                                                   das wesentliche Aussehen des Buttons festlegen, wobei Sie das Bild im Vordergrund
                                                   und den Titel über <span class="cbegriff">Insets</span> beliebig positionieren können.
                                                </p><a href="bilder/03_020.png" rel="lightbox" title="Die Darstellungselemente eines Buttons"><img class="bild" border="1" src="bilderklein/klein03_020.png" alt="Abbildung"></a><p class="pbildunter"><strong>Abbildung 3.20   </strong>Die Darstellungselemente eines Buttons
                                                </p>
                                                <p>Wenn Sie für eine Zustandskombination eine Darstellungseigenschaft nicht definieren,
                                                   wird stattdessen die des Normalzustands verwendet. Im Interface Builder können Sie
                                                   alle Eigenschaften für die einfachen Zustände, aber nicht für Kombinationen aus mehreren
                                                   Zuständen festlegen. Sie können also beispielsweise das Hintergrundbild für den Zustand
                                                   <span class="cbegriff">Selected</span> festlegen aber nicht für <span class="cbegriff">Selected + Highlighted</span>. Das geht nur über Programmcode.
                                                </p>
                                                <p>Durch die Möglichkeit, für die verschiedenen Buttonzustände unterschiedliche Darstellungen
                                                   festzulegen, können Sie Ihren Apps relativ einfach optisch ansprechende Buttons hinzufügen
                                                   und damit auch fehlende Buttontypen (beispielsweise Checkboxen) basteln. Die Uhr können
                                                   Sie auch über einen einrastenden Button anstatt einem Schalter steuern. Das Einrasten
                                                   wird durch Invertierung des Zustandes <span class="cbegriff">Selected</span> erreicht. Die Action-Methode <span class="clisting">switchAnimation:</span> müssen Sie wie folgt ändern:
                                                </p>
                                                <div class="listing"><pre class="prettyprint">- (IBAction)switchAnimation:(UIButton *)inSender {<br>    inSender.selected = !inSender.selected;<br>    if(inSender.selected) {<br>        [clockView startAnimation];<br>    }<br>    else {<br>        [clockView stopAnimation];<br>    }<br>}<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.27   </strong>Action-Methode für einen einrastenden Button
                                                </p>
                                                <p>Natürlich müssen Sie auch die Deklaration der Methode in der Headerdatei entsprechend
                                                   ändern. Legen Sie im Interface Builder einen Button an, und stellen Sie über dessen
                                                   Attributinspektor für die Zustände <span class="cbegriff">Default</span><span class="ckursiv">,</span> <span class="cbegriff">Highlighted</span> und <span class="cbegriff">Selected</span> die Titel <span class="cbegriff">ein</span><span class="ckursiv">,</span> <span class="cbegriff">klick</span> beziehungsweise <span class="cbegriff">aus</span> ein.
                                                </p><a href="bilder/03_021.png" rel="lightbox" title="Der Attributinspektor eines Buttons"><img class="bild" border="1" src="bilderklein/klein03_021.png" alt="Abbildung"></a><p class="pbildunter"><strong>Abbildung 3.21   </strong>Der Attributinspektor eines Buttons
                                                </p>
                                                <p>Verbinden Sie den Button mit der Action-Methode, indem Sie ein Band vom Button zum
                                                   <span class="cscreenelement">File&#8217;s Owner</span> ziehen. Wenn Sie das Band dort loslassen, erscheint ein Dialog, in dem Sie die Action-Methode
                                                   auswählen können. Im Verbindungsinspektor des Buttons können Sie sehen, dass der Interface
                                                   Builder automatisch die Action-Methode mit dem Ereignis <span class="cbegriff">Touch Up Inside</span> verbunden hat. Der Button sendet dieses Ereignis, wenn der Finger den Button losgelassen
                                                   hat.
                                                </p>
                                                <p>Nach dem Start des Programms ist die Uhr ausgeschaltet und der Button zeigt die Beschriftung
                                                   <span class="cscreenelement">ein</span>. Wenn Sie den Button drücken, wechselt die Beschriftung auf <span class="cscreenelement">klick</span> und nach dem Loslassen auf <span class="cscreenelement">aus</span>. In diesem Zustand verbleibt der Button, und die Uhr läuft.
                                                </p>
                                                <p>Durch erneutes Drücken des Buttons wechselt die Beschriftung wieder auf <span class="cscreenelement">ein</span>. Der Button hat doch den Zustand <span class="cbegriff">Highlighted</span>. Warum erscheint hier nicht auch die Beschriftung <span class="cscreenelement">klick</span>? Das liegt daran, dass die Zustände <span class="cbegriff">Highlighted</span> und <span class="cbegriff">Selected</span> gesetzt sind. Für diese Zustandskombination haben Sie jedoch keinen Titel festgelegt,
                                                   sodass der Button den Titel des Zustands <span class="cbegriff">Default</span> verwendet.
                                                </p>
                                                <p>Den Titel für diese Zustandskombination können Sie nicht im Interface Builder festlegen,
                                                   sondern müssen das im Programmcode machen. Dafür legen Sie ein Outlet auf den Button
                                                   an. Die Klasse <span class="clisting">UIViewController</span> besitzt eine weitere Methode <span class="clisting">viewDidLoad</span>, die aufgerufen wird, wenn der View geladen wurde.
                                                </p>
                                                <p>Da der Button für den Zustand <span class="cbegriff">Selected + Highlighted</span> den gleichen Titel wie für den Zustand <span class="cbegriff">Selected</span> verwenden soll, kopiert die Methode den Titel. Dadurch können Sie den Titel allein
                                                   über den Interface Builder pflegen. Durch diese Änderung zeigt der Button in der oben
                                                   beschriebenen Situation jetzt auch den Titel <span class="cscreenelement">klick</span> anstatt <span class="cscreenelement">ein</span> an.
                                                </p>
                                                <div class="listing"><pre class="prettyprint">- (void)viewDidLoad {<br>    [super viewDidLoad];<br>    NSString *theTitle =<br>        [switchButton titleForState:UIControlStateHighlighted];<br>    [switchButton setTitle:theTitle<br>                  forState:UIControlStateSelected |<br>                           UIControlStateHighlighted];<br>}<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.28   </strong>Initialisierung eines Buttons nach dem Laden des Views
                                                </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtp3a191257-4e08-4274-8b17-625b0208638b" name="dodtp3a191257-4e08-4274-8b17-625b0208638b"></a><h3 class="t3"><span class="cfett">3.2.6</span><span class="cfett"> Direkte Gestenverarbeitung</span><a href="#dodtpbc46c62d-db40-4709-8cbc-4580da56485f"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#dodtp009b4d3a-a199-4df6-bd87-5e229a18375d"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
                                                <p>Sie können den Target-Action-Mechanismus für die Gestenverarbeitung einsetzen. Dieses
                                                   Vorgehen ist aber recht aufwendig, wenn Sie eine Geste wiederverwenden möchten. Cocoa
                                                   Touch bietet noch andere Möglichkeiten, um Gesten zu verarbeiten.
                                                </p>
                                                <p>Damit ein View die Touch-Ereignisse empfängt, müssen Sie dessen Property <span class="clisting">userInteractionEnabled</span><a class="indexterm" id="dodtpf9d2fafa-cb87-48af-91be-072d9682ac7f"></a> setzen. Cocoa Touch durchsucht in der View-Hierarchie nur diese Views und sendet
                                                   die Ereignisse an den tiefsten View, unter dem der Berührungspunkt des Fingers liegt.
                                                   Mit <span class="cbegriff">der tiefste View</span> ist gemeint, dass es in diesem View keinen weiteren Subview an der Fingerposition
                                                   mit gesetzter Property <span class="clisting">userInteractionEnabled</span> gibt.
                                                </p>
                                                <table width="100%" border="0" cellspacing="1" cellpadding="3">
                                                   <tbody>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellenkopf"><span class="cfett">
                                                               
                                                               
                                                               
                                                               Der View muss auch wollen
                                                               
                                                               </span></td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext">
                                                            <p>Sie können über <span class="clisting">userInteractionEnabled</span> die Touchverarbeitung komplett ausschalten. Wenn Sie diesen Propertywert also auf
                                                               <span class="clisting">NO</span> setzen, reagieren weder der View noch seine Subviews mehr auf Berührungen. Dabei
                                                               ist es egal, ob Sie ein <span class="cbegriff">Control</span> verwenden oder die Touches direkt oder über eine andere Methodik auswerten. Bei <span class="clisting">userInteractionEnabled = NO</span> ignoriert der View Ihre Berührungen &#8211; mögen Sie ihn noch so zärtlich streicheln.
                                                               
                                                               
                                                            </p>
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                   </tbody>
                                                </table>
                                                <p>Die Klasse <span class="clisting">UIView</span> stellt zwei Methoden bereit, um den Subview zu bestimmen, der die Gesten verarbeitet.
                                                   Die Methode <span class="clisting">hitTest:withEvent:</span><a class="indexterm" id="dodtp251709c0-fa72-4ae6-96a9-79ca3f115d35"></a> bestimmt zu einem Punkt den Subview, der die Gestenverarbeitung übernehmen soll.
                                                   Sie verwendet dazu die Methode <span class="clisting">pointInside:withEvent:</span><a class="indexterm" id="dodtpf984b587-babb-44d9-acd6-cf5a297661e3"></a>.
                                                </p>
                                                <p>Sie entscheidet, ob der angegebene Punkt in dem View liegt oder nicht. Während der
                                                   Eventparameter bei beiden Methoden <span class="clisting">nil</span> sein darf, müssen Sie den Punkt relativ zu dem Koordinatensystem des Views angeben.
                                                   Wenn Sie diese Methode aus dem Programmcode aufrufen, müssen Sie also in der Regel
                                                   den Punkt erst umrechnen.
                                                </p>
                                                <p>Die Klasse <span class="clisting">UIView</span> stellt dafür die Methoden <span class="clisting">convertPoint:fromView:</span><a class="indexterm" id="dodtpdf60da7f-e6dd-4e4c-9116-dbb5e39ed9f0"></a> und <span class="clisting">convertPoint:toView:</span><a class="indexterm" id="dodtp3e47ee9e-a507-40cd-88b6-707cdf7d4401"></a> bereit. Die erste Methode rechnet den Punkt aus dem Koordinatensystem des zweiten
                                                   Parameters in das Koordinatensystem des Empfängers um. Bei der zweiten Methode sind
                                                   die Koordinatensysteme des zweiten Parameters und des Empfängers bei der Berechnung
                                                   vertauscht.
                                                </p>
                                                <table width="100%" border="0" cellspacing="1" cellpadding="3">
                                                   <tbody>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellenkopf"><span class="cfett">
                                                               
                                                               
                                                               
                                                               ...und raus bist du!
                                                               
                                                               </span></td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext">
                                                            <p>Wenn Sie die View-Bestimmung für die Gestenverarbeitung anpassen möchten, sollten
                                                               Sie in Ihren Views die Methode <span class="clisting">pointInside:withEvent:</span> überschreiben. Ein Überschreiben der Methode <span class="clisting">hitTest:withEvent:</span> ist in der Regel nicht notwendig.
                                                               
                                                               Sofern Sie den Propertywert <span class="clisting">clipsToBounds</span> eines Views auf <span class="clisting">NO</span> setzen, kann jeder Subview des Views über dessen Grenzen hinaus zeichnen. Allerdings
                                                               empfängt der Subview auch nur da Touches, wo er innerhalb seiner Superviews liegt.
                                                               
                                                               
                                                            </p>
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      
                                                      
                                                   </tbody>
                                                </table><a id="dodtpa1ccd954-9d7c-4222-86aa-39a66db99166" name="dodtpa1ccd954-9d7c-4222-86aa-39a66db99166"></a><h4 class="t4"><span class="cfett"></span><span class="cfett"> Gestenverarbeitung über Responder</span></h4>
                                                <p>Die Klasse <span class="clisting">UIResponder</span><a class="indexterm" id="dodtp9bd90367-e3a6-4a2d-9397-627302dd0b16"></a> ist die direkte Oberklasse von <span class="clisting">UIView</span><a class="indexterm" id="dodtp56d7bfe0-ba5c-4a3d-8ee4-11413675a401"></a> und <span class="clisting">UIViewController</span><a class="indexterm" id="dodtp67657a6c-ff39-4a48-8a4d-f78d6a341823"></a>. Sie stellt mehrere Methoden zur Auswertung von Gesten bereit. Die Methoden für die
                                                   Berührungsgesten haben jeweils zwei Parameter und liefern <span class="clisting">void</span> zurück. Der erste Parameter ist eine Menge von <span class="clisting">UITouch</span>-Objekten, die eine Fingerberührung auf dem Bildschirm repräsentieren. Der zweite
                                                   Parameter ist ein <span class="clisting">UIEvent</span>-Objekt.
                                                </p>
                                                <p>Der Methodenaufruf von <span class="clisting">touchesBegan:withEvent:</span><a class="indexterm" id="dodtpcbdb4e87-7696-49c2-bde3-242ec906ba5e"></a> leitet eine Gestensequenz ein. Die folgenden Fingerbewegungen erhält der Responder
                                                   über die Methode <span class="clisting">touchesMoved:withEvent:</span><a class="indexterm" id="dodtp34a00cdd-2824-4478-9ec2-8664a1e9000d"></a>. Abgeschlossen wird die Geste über einen Aufruf von entweder <span class="clisting">touchesEnded:withEvent:</span><a class="indexterm" id="dodtp999e1ab2-f32a-47be-882a-e8a26698c2ae"></a> oder <span class="clisting">touchesCancelled:withEvent:</span><a class="indexterm" id="dodtpd5352759-c069-47f8-963c-771bd1b99817"></a>. Dabei kennzeichnet ein Aufruf der Methode <span class="clisting">touchesCancelled:withEvent:</span>, dass das System eine Geste abbrechen möchte (siehe dazu die Beschreibung zu <span class="clisting">UIControlEventTouchCancel</span> in Abschnitt 3.2.4).
                                                </p>
                                                <p>Diese Methoden sind die Grundlagen der Gestenverarbeitung. Allerdings führt die Verwendung
                                                   dieser Methoden in der Regel zu einer relativ festen Koppelung von View und Controller.
                                                   Meistens muss der View das Ergebnis einer Geste an den Controller weiterreichen.
                                                </p>
                                                <table width="100%" border="0" cellspacing="1" cellpadding="3">
                                                   <tbody>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellenkopf"><span class="cfett">
                                                               
                                                               
                                                               
                                                               Tipp
                                                               
                                                               </span></td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext">
                                                            <p>Falls Sie eine eigene Gestenverarbeitung über diese Responder-Methoden realisieren
                                                               möchten, sollten Sie die Kommunikation mit dem Controller über Delegation realisieren.
                                                               Eine direkte Verwendung von Controller-Eigenschaften im View ist eine Verletzung des
                                                               MVC-Architekturmusters<a class="indexterm" id="dodtp726f79d2-628b-456b-a16e-f21961a9be0e"></a>, weil dadurch der View abhängig von der Controller-Schicht ist. Es ist ja auch nicht
                                                               besonders schwer, eine Delegate-Property und ein Protokoll zu erstellen.
                                                               
                                                               
                                                            </p>
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                   </tbody>
                                                </table><a id="dodtp3540a5fe-3333-43c8-99ee-be3698f6ba65" name="dodtp3540a5fe-3333-43c8-99ee-be3698f6ba65"></a><h4 class="t4"><span class="cfett"></span><span class="cfett"> Gestenverarbeitung über Controls</span></h4>
                                                <p>Eine andere Möglichkeit, einen Controller lose an einen View zu koppeln, ist die Verwendung
                                                   des Target-Action-Mechanismus<a class="indexterm" id="dodtp1e74d3f6-d5a2-4fc7-bbae-b42e1fa88d7f"></a>. Dafür können Sie eigene Unterklassen von <span class="clisting">UIControl</span> erstellen. Die Klasse <span class="clisting">UIControl</span> stellt ebenfalls vier Methoden zur Gestenverarbeitung bereit. Diese sind den Methoden
                                                   der Klasse <span class="clisting">UIResponder</span> sehr ähnlich. Die Methoden <span class="clisting">beginTrackingWithTouch:withEvent:</span><a class="indexterm" id="dodtpf1efafa8-b74a-4ef6-9f80-2946f78ee8d4"></a>, <span class="clisting">continueTrackingWithTouch:withEvent:</span><a class="indexterm" id="dodtp1e0079be-eb77-4129-905a-d28a1a9e8232"></a> und <span class="clisting">endTrackingWithTouch:withEvent:</span><a class="indexterm" id="dodtp68509f80-86d3-4d7b-8522-b0732cf8b5c2"></a> erhalten jeweils zwei Parameter, wovon der erste ein Touchobjekt und der zweite der
                                                   Event ist. Im Gegensatz zu den Respondermethoden erhalten Sie hier also nicht alle
                                                   Berührungen des Bildschirms als direkte Parameter. Falls Sie eine Mehrfingergeste
                                                   implementieren möchten, können Sie jedoch alle Berührungen über die Methode <span class="clisting">allTouches</span> des Events abfragen. Außerdem gibt es noch die Methode <span class="clisting">cancelTrackingWithEvent:</span><a class="indexterm" id="dodtp840ae3ef-a71b-4d95-9f99-6363439e0c5d"></a>, die analog zu <span class="clisting">touchesCancelled:withEvent:</span> beim Abbruch einer Geste aufgerufen wird.
                                                </p>
                                                <p>Mit der Gestenverarbeitung soll aus der Uhr ein Wecker entstehen. Bei einem analogen
                                                   Wecker gibt es neben den Zeigern für die Zeitanzeige einen weiteren Zeiger für die
                                                   Alarmzeit. In der Wecker-App soll der Nutzer diesen Zeiger durch Berührung und Bewegung
                                                   mit dem Finger einstellen können. Das Control muss also eine Drehbewegung mit einem
                                                   Finger auf dem Bildschirm erkennen. Diese Bewegung ähnelt dem Wählen auf einem Telefon
                                                   mit Wählscheibe. Das Control soll auch die Darstellung des Alarmzeigers übernehmen.
                                                </p>
                                                <p>Das Control erhält für die Darstellung der Alarmzeit die Property <span class="clisting">time</span>. Die Alarmzeit kann über die Methode <span class="clisting">angle</span> in einen Winkel umgerechnet und über die Methode <span class="clisting">setAngle:</span> als Winkelwert gesetzt werden. Die Methoden <span class="clisting">midPoint</span> und <span class="clisting">pointWithRadius:angle:</span> aus der Klasse <span class="clisting">ClockView</span> werden in die Kategorie <span class="clisting">UIView(AlarmClock)</span> ausgelagert, damit sowohl die View- als auch die Control-Klasse sie verwenden können.
                                                   Die Methode <span class="clisting">angleWithPoint:</span> berechnet über die C-Funktion <span class="clisting">atan2</span> zu einem Punkt im Control den Winkel der Linie, die vom Mittelpunkt zu diesem Punkt
                                                   führt:
                                                </p>
                                                <div class="listing"><pre class="prettyprint">-(CGFloat)angleWithPoint:(CGPoint)inPoint {<br>    CGPoint theCenter = [self midPoint];<br>    CGFloat theX = inPoint.x &#8211; theCenter.x;<br>    CGFloat theY = inPoint.y &#8211; theCenter.y;<br>    CGFloat theAngle = atan2f(theX, -theY);<br>    return theAngle &lt; 0 ? theAngle + 2.0 * M_PI : theAngle;<br>}<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.29   </strong>Berechnung des Winkels zu einem Punkt
                                                </p>
                                                <p>Der Winkel, den die Funktion <span class="clisting">atan2</span> berechnet, liegt zwischen &#8211; und . Negative Werte müssen Sie also auf entsprechende
                                                   positive Werte umrechnen.
                                                </p>
                                                <p>Der Zeiger soll sich nur verstellen lassen, wenn die Fingerberührung in der Nähe des
                                                   Zeigers ist. Dazu überschreiben Sie die Methode <span class="clisting">pointInside:withEvent:</span><a class="indexterm" id="dodtp434374a6-432c-4a93-9430-1d87a0f79e79"></a></p>
                                                <div class="listing"><pre class="prettyprint">- (BOOL)pointInside:(CGPoint)inPoint<br>          withEvent:(UIEvent *)inEvent {<br>    CGFloat theAngle = [self angleWithPoint:inPoint];<br>    CGFloat theDelta = fabs(theAngle &#8211; self.angle);<br>    return theDelta &lt; 2 * M_PI / 180.0;<br>}<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.30   </strong>Prüfung, ob ein Punkt in der Nähe des Alarmzeigers liegt
                                                </p>
                                                <p>Die Variable <span class="clisting">theDelta</span> enthält den Winkelabstand des Fingers vom Zeiger. Wenn dieser Windel kleiner als
                                                   2° ist, soll das Control den Touch verarbeiten.
                                                </p>
                                                <p>Zu Beginn der Gestenverarbeitung speichert das Control den alten Winkel in der Property
                                                   <span class="clisting">savedAngle</span>. Ansonsten enthält die Begin-, die Continue- und die End-Tracking-Methode den gleichen
                                                   Code:
                                                </p>
                                                <div class="listing"><pre class="prettyprint">CGPoint thePoint = [inTouch locationInView:self];<br>self.angle = [self angleWithPoint:thePoint];<br>[self setNeedsDisplay];<br>[self sendActionsForControlEvents: UIControlEventValueChanged];<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.31   </strong>Aktualisierung der Daten in den Tracking-Methoden
                                                </p>
                                                <p>Die Methoden berechnen jeweils den neuen Winkel, speichern ihn in <span class="clisting">angle</span> und zeichnen den Zeiger neu (Zeilen 1 bis 3). Anschließend lösen sie das Ereignis
                                                   <span class="clisting">UIControlEventValueChanged</span> aus, das die Action-Methoden aller Target-Objekte aufruft.
                                                </p>
                                                <p>In der XIB-Datei können Sie jetzt das Control in den Clock-View legen, wenn Sie dem
                                                   Control eine transparente Hintergrundfarbe geben. Sie müssen die Property <span class="clisting">userInteractionEnabled</span> des Views auf <span class="clisting">YES</span> setzen, damit die Gesten auch an das Control gesendet werden. Im Beispielprojekt
                                                   auf der beigelegten DVD ist ein Label mit einem Outlet <span class="clisting">timeLabel</span> angelegt, das die aktuelle Weckzeit als Text anzeigt.
                                                </p>
                                                <p>Für die Aktualisierung wird der Ereignistyp <span class="cbegriff">Value Changed</span> im Interface Builder mit der Methode <span class="clisting">updateTimeLabel</span> verbunden. Sobald Sie den Alarmzeiger bewegen, sendet das Control dieses Ereignis.
                                                   Die Aktualisierung erfolgt durch folgende Anweisungen:
                                                </p>
                                                <div class="listing"><pre class="prettyprint">NSInteger theTime = round(clockControl.time / 60.0);<br>NSInteger theMinutes = theTime % 60;<br>NSInteger theHours = theTime / 60;<br>timeLabel.text = [NSString stringWithFormat:@"%d:%02d", theHours, theMinutes];<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.32   </strong>Erzeugung einer Zeichenkette aus einer Zeit
                                                </p>
                                                <p>Dem Wecker fehlt jetzt nur noch die Weckfunktion, also das Klingeln. Das behandelt
                                                   Abschnitt 3.3.
                                                </p><a id="dodtpa8131d38-d46e-4c85-9891-97b01b5ed249" name="dodtpa8131d38-d46e-4c85-9891-97b01b5ed249"></a><h4 class="t4"><span class="cfett"></span><span class="cfett"> Gestenverarbeitung über Gesturerecognizer</span></h4>
                                                <p>Mit der iOS-Version 3.2 <span class="footnote"><a id="dodtp1c91f287-ddf0-4f67-9bdc-8d4d5b0f9889">[16](Diese Version war auf das iPad beschränkt. Für alle anderen Gerätetypen gibt es die Gesturerecognizer erst ab iOS 4.0.)</a></span> beziehungsweise 4.0 hat Apple eine weitere Möglichkeit der Gestenverarbeitung eingeführt.
                                                   Die Klasse <span class="clisting">UIGestureRecognizer</span><a class="indexterm" id="dodtpa2223e7a-0e5f-47e7-8f1d-743600676f91"></a> ermöglicht eine Implementierung von Gestensteuerungen, die von den Views getrennt
                                                   ist. Damit können Sie jede beliebige Gestenverarbeitung zu jedem View hinzufügen.
                                                   Die Darstellung und die Eingabeverarbeitung eines Views werden also durch Gesturerecognizers<a class="indexterm" id="dodtpd7425c4f-2f1d-41ac-aba3-735c8c20daa8"></a> vollkommen unabhängig voneinander oder auch <span class="cbegriff">orthogonal</span><a class="indexterm" id="dodtpe4399a93-aa99-4f74-8597-5f522a081d36"></a>.
                                                </p>
                                                <p>Die Klasse <span class="clisting">UIView</span> bietet zwei Methoden und eine Property zum Verwalten von Gesturerecognizern an. Mit
                                                   <span class="clisting">addGestureRecognizer:</span> fügen Sie einem View einen neuen Gesturerecognizer hinzu, den Sie mit <span class="clisting">removeGestureRecognizer:</span> wieder entfernen können. Mit der Property <span class="clisting">gestureRecognizers</span> können Sie alle Gesturerecognizers des Views abfragen oder auf einmal setzen. Mit
                                                   Xcode 4.2<a class="indexterm" id="dodtpa79e375a-b295-42be-a9c7-d3f731bf2dbf"></a> können Sie die Gesture-Recognizer auch direkt über den Interface Builder zu Ihren
                                                   Views hinzufügen.
                                                </p><a href="bilder/03_022.png" rel="lightbox" title="Die Gesturerecognizer in Xcode 4.2"><img class="bild" border="1" src="bilderklein/klein03_022.png" alt="Abbildung"></a><p class="pbildunter"><strong>Abbildung 3.22   </strong>Die Gesturerecognizer in Xcode 4.2
                                                </p>
                                                <p>Das UIKit bietet schon eine Reihe fertiger Gesturerecognizer. Die Klassen sind in
                                                   der gleichen Reihenfolge wie die Icons in Abbildung 3.22 aufgeführt.
                                                </p>
                                                <ol class="paufz">
                                                   <li><span class="clisting">UITapGestureRecognizer</span><a class="indexterm" id="dodtpc991f0a6-cacd-463f-8a25-0478a0306d2f"></a> erkennt einzelne oder mehrere Berührungen des haltenden Views. Sie können sowohl
                                                      die notwendige Tap-Zahl als auch die Anzahl der beteiligten Finger zur Auslösung vorgeben.
                                                   </li>
                                                   <li><span class="clisting">UIPinchGestureRecognizer</span><a class="indexterm" id="dodtp81f79da2-8232-4687-bbb2-d652d99d590d"></a> erkennt die Bewegung von zwei Fingern aufeinander zu oder voneinander weg. Diese
                                                      Geste wird meistens zum Heraus- beziehungsweise Hereinzoomen verwendet.
                                                   </li>
                                                   <li><span class="clisting">UIRotationGestureRecognizer</span><a class="indexterm" id="dodtp3a3ec46c-93f8-4074-85ea-6ce54d367e82"></a> erkennt die Bewegung von zwei sich umeinander drehenden Fingern, wie sie meist für
                                                      die Rotation von Bildern eingesetzt wird.
                                                   </li>
                                                   <li><span class="clisting">UISwipeGestureRecognizer</span><a class="indexterm" id="dodtp9bac8d20-6289-49df-bc76-42cf54036e29"></a> erkennt Wischbewegungen. Sie können die Anzahl der beteiligten Finger angeben, aber
                                                      damit nur die Richtung und keine Distanzen auswerten.
                                                   </li>
                                                   <li><span class="clisting">UIPanGestureRecognizer</span><a class="indexterm" id="dodtpc4bd69a7-a96e-4886-8ec7-4f486e72bd5b"></a> erkennt Verschiebe-Bewegungen in einem View. Sie können damit beispielsweise das
                                                      Verschieben eines Views innerhalb eines anderen durchführen (<span class="cbegriff">Dragging</span>). Auch bei diesem Gesturerecognizer können Sie die Anzahl der beteiligten Finger
                                                      vorgeben.
                                                   </li>
                                                   <li><span class="clisting">UILongPressGestureRecognizer</span><a class="indexterm" id="dodtp901319d2-5c2e-4237-9cbd-2ff32965351f"></a> erkennt längere Berührungen des zugrunde liegenden Views. Diese Gestenauswertung
                                                      wird häufig eingesetzt, wenn ein View unterschiedliche Gestenarten unterstützen soll.
                                                      Beispielsweise können Sie eine Karte scrollen und durch längeres Drücken einen Pin
                                                      setzen. Auch bei diesem Gesturerecognizer können Sie die Anzahl der beteiligten Finger
                                                      einschränken. Außerdem können Sie eine minimale Dauer für die Berührungslänge wählen.
                                                   </li>
                                                </ol>
                                                <p>Sie können auch eigene Unterklassen der Klasse <span class="clisting">UIGestureRecognizer</span> schreiben und so eine eigene Gestenverarbeitung implementieren. Dafür werden die
                                                   gleichen Methoden verwendet, die auch die Klasse <span class="clisting">UIResponder</span> bereitstellt. Zusätzlich gibt es eine Methode <span class="clisting">reset</span>. Sie können diese Methode überschreiben, um nach dem Abschluss einer Geste Ihren
                                                   Gesturerecognizer für die nächste Geste zurückzusetzen.
                                                </p>
                                                <p>Gesturerecognizer unterstützen wie Controls den Target-Action-Mechanismus &#8211; allerdings
                                                   ohne Ereignistypen. Sie können über die Methode <span class="clisting">addTarget: action:</span><a class="indexterm" id="dodtp370d8ea5-a259-4f7d-9405-edb362d16f79"></a> eine neue Aktion hinzufügen, die Sie mit <span class="clisting">removeTarget:action:</span><a class="indexterm" id="dodtp0ce04aef-fc97-4c71-8307-c306bb8ce3c5"></a> auch wieder entfernen können.
                                                </p>
                                                <p>Das Beispielprojekt verwendet einen <span class="clisting">UILongPressGestureRecognizer</span>, um die Alarmzeit zusätzlich zur Zeigerdrehung einstellen zu können. Wenn Sie länger
                                                   als vier Zehntelsekunden das Ziffernblatt mit einem Finger berühren, wird der Alarmzeiger
                                                   eingeschaltet und an der Position des Fingers angezeigt.
                                                </p>
                                                <p>In der Methode <span class="clisting">viewDidLoad</span> erstellen Sie einen neuen Gesturerecognizer und fügen ihn dem Control hinzu:
                                                </p>
                                                <div class="listing"><pre class="prettyprint">UILongPressGestureRecognizer *theRecognizer = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(updateAlarmHand:)];<br>[self.clockControl addGestureRecognizer:theRecognizer];<br>[theRecognizer release];<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.33   </strong>Erzeugung eines Gesturerecognizers
                                                </p>
                                                <p>Die Action-Methode eines Gesturerecognizers hat entweder keinen oder genau einen Parameter.
                                                   In diesem Parameter bekommen Sie den Gesturerecognizer übergeben, und er sollte dessen
                                                   Typ haben. Die Action-Methode für den Wecker muss die Position des Fingers auslesen.
                                                   Dazu bietet die Klasse <span class="clisting">UIGestureRecognizer</span> die Methode <span class="clisting">locationInView:</span><a class="indexterm" id="dodtp5f4ed66f-14ed-4159-88a2-0be10468a2cd"></a>, mit der Sie die Fingerposition relativ zu dem Koordinatensystem eines Views berechnen
                                                   können.
                                                </p>
                                                <p>Die Action-Methode <span class="clisting">updateClockHand:</span> können Sie jetzt folgendermaßen implementieren:
                                                </p>
                                                <div class="listing"><pre class="prettyprint">-(void)updateAlarmHand:(UIGestureRecognizer *)inRecognizer {<br>    CGPoint thePoint =<br>        [inRecognizer locationInView:clockControl];<br>    CGFloat theAngle =<br>        [self.clockControl angleWithPoint:thePoint];<br>    self.clockControl.angle = theAngle;<br>    [self.clockControl setNeedsDisplay];<br>    self.alarmSwitch.on = YES;<br>    [self updateAlarm];<br>}<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.34   </strong>Action-Methode zur Aktualisierung des Alarmzeigers
                                                </p><a id="dodtpce0f1aec-dbb0-4e14-9ff8-efd251212c3d" name="dodtpce0f1aec-dbb0-4e14-9ff8-efd251212c3d"></a><h4 class="t4"><span class="cfett"></span><span class="cfett"> Die Qual der Wahl</span></h4>
                                                <p>Sie haben drei Möglichkeiten zur Gestenverarbeitung kennengelernt. Welche ist denn
                                                   nun die beste? Das hängt natürlich von dem Anwendungsfall ab. Tabelle 3.1 listet die
                                                   verschiedenen Möglichkeiten für die Gestenverarbeitung auf.
                                                </p>
                                                <table width="100%" border="0" cellspacing="1" cellpadding="3">
                                                   <caption class="tabunter">
                                                      <p class="ptabellenunter"> <strong>Tabelle 3.1   </strong>Vor- und Nachteile verschiedener Möglichkeiten zur Gestenerkennung
                                                      </p>
                                                   </caption>
                                                   <tbody>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellenkopf">
                                                            
                                                            
                                                            
                                                            <span class="cfett">Gestenverarbeitung</span>
                                                            
                                                            
                                                         </td>
                                                         
                                                         
                                                         <td class="tabellenkopf"><span class="cfett">Vor- und Nachteile</span>
                                                            
                                                            
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext" rowspan="2">Überschreiben der <br>Respondermethoden
                                                            
                                                            
                                                         </td>
                                                         
                                                         
                                                         <td class="tabellentext">Vorteile
                                                            <br>
                                                            1. Gestenverarbeitung auch im Viewcontroller und nicht nur im View möglich.
                                                            <br>
                                                            2. Auswertung mehrerer unterschiedlicher Gesten innerhalb eines Views
                                                            
                                                            
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext">Nachteile
                                                            <br>
                                                            1. Gefahr der Verletzung des MVC-Musters: Abhängigkeit des Views vom Controller
                                                            
                                                            
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext" rowspan="2">Unterklasse von <span class="clisting">UIControl</span>
                                                            
                                                            
                                                         </td>
                                                         
                                                         
                                                         <td class="tabellentext">Vorteile
                                                            <br>
                                                            1. Nutzung des Target-Action-Mechanismus und dadurch keine Abhängigkeit des Views vom
                                                            Viewcontroller
                                                            <br>
                                                            2. Nutzung der Action-Connections im Interface Builder
                                                            <br>
                                                            3. Hohe Wiederverwendbarkeit möglich
                                                            
                                                            
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext">Nachteile
                                                            <br>
                                                            1. Keine eigenen Eventtypen
                                                            
                                                            
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext" rowspan="2">Unterklasse von <span class="clisting">UIGestureRecognizer</span>
                                                            
                                                            
                                                         </td>
                                                         
                                                         
                                                         <td class="tabellentext">Vorteile
                                                            <br>
                                                            1. Gestenverarbeitung komplett von der Darstellung getrennt
                                                            <br>
                                                            2. Viele fertige Recognizer vorhanden
                                                            <br>
                                                            3. Höchster Wiederverwendungsgrad, da die Gestenerkennung komplett von der Darstellung
                                                            getrennt ist
                                                            
                                                            
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext">Nachteile
                                                            <br>
                                                            1. Erst ab iOS 3.2
                                                            
                                                            
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                   </tbody>
                                                </table>
                                                <p>Der Hauptnachteil bei der Verwendung der Respondermethoden, die enge Koppelung des
                                                   Views an den Viewcontroller, kann natürlich auch bei undurchdachter Implementierung
                                                   der anderen Verfahren auftreten. Bei der Verwendung des Respondermechanismus tappen
                                                   jedoch viele Programmierer in diese Falle. Sie können eine starke Koppelung jedoch
                                                   über Delegation vermeiden.
                                                </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtpbc46c62d-db40-4709-8cbc-4580da56485f" name="dodtpbc46c62d-db40-4709-8cbc-4580da56485f"></a><h3 class="t3"><span class="cfett">3.2.7</span><span class="cfett"> Übergänge</span><a href="#dodtp197deaea-4bd9-433f-a357-f8ab4a157ca6"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#dodtpce0f1aec-dbb0-4e14-9ff8-efd251212c3d"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
                                                <p>Mit iOS 5 und den Storyboards<a class="indexterm" id="dodtpb9ba8f35-baa0-462a-a74c-9480dce003ba"></a> hat Apple auch <span class="cbegriff">Segues</span><a class="indexterm" id="dodtp97487335-d23c-4b23-8d15-2766980031c0"></a> (Übergänge<a class="indexterm" id="dodtp37a853a2-71e3-448b-80df-a6a57c1bbb6b"></a>) eingeführt. Diese Objekte beschreiben einen Übergang von einem Viewcontroller zu
                                                   einem anderen. Übergänge haben somit als Verbindungstyp im Interface Builder einen
                                                   sehr eingeschränkten Anwendungsbereich. Andererseits können Sie darüber schon im Interface
                                                   Builder eine Verknüpfung zwischen den UI-Elementen und den Views festlegen. Deswegen
                                                   nennt Apple diese neuen Beschreibungsdateien für die Views auch <span class="cbegriff">Storyboards</span>.
                                                </p>
                                                <p>Um die Funktionsweise der Übergänge zu veranschaulichen, erstellen Sie dafür ein kleines
                                                   Projekt. Sie finden es unter dem Namen <span class="cdateipfad">Segue</span> auch auf der beiligenden DVD. Legen Sie dazu in Xcode ein neues iPad-Projekt des
                                                   Typs <span class="cbegriff">Single View Application</span> an, und geben Sie an, dass dieses Projekt ein Storyboard verwenden soll. Öffnen Sie
                                                   das Storyboard, und legen Sie einen neuen Button in den dort angezeigten View. Danach
                                                   ziehen Sie einen neuen Viewcontroller (siehe Abbildung 3.23) auf die Zeichenfläche
                                                   des Storyboards.
                                                </p><a href="bilder/03_023.png" rel="lightbox" title="Die Viewcontroller im Interface Builder"><img class="bild" border="1" src="bilderklein/klein03_023.png" alt="Abbildung"></a><p class="pbildunter"><strong>Abbildung 3.23   </strong>Die Viewcontroller im Interface Builder
                                                </p>
                                                <p>Als Nächstes legen Sie einen Übergang an, indem Sie bei gedrückter rechter Maustaste
                                                   ein Gummiband vom Button zu dem neuen Viewcontroller ziehen. Nachdem Sie in dem schwarzen
                                                   Dialog den Eintrag <span class="clisting">performSegueWithIdentifier:sender:</span><a class="indexterm" id="dodtp70e5d658-b0bc-4fe2-9eb9-cfb37adb3de2"></a> ausgewählt haben, zeigt der Interface Builder zwischen den Viewcontrollern einen
                                                   grauen Pfeil mit einem Symbol in der Mitte an. Im Attributinspektor dieses Segues
                                                   können Sie jetzt festlegen, wie der Übergang erfolgen soll. Wählen Sie unter <span class="cscreenelement">Style</span> die Option <span class="cscreenelement">Modal</span> und unter <span class="cscreenelement">Presentation</span> den Punkt <span class="cscreenelement">Form Sheet</span> aus (siehe Abbildung 3.24).
                                                </p><a href="bilder/03_024.png" rel="lightbox" title="Ein Übergang zwischen zwei Viewcontrollern"><img class="bild" border="1" src="bilderklein/klein03_024.png" alt="Abbildung"></a><p class="pbildunter"><strong>Abbildung 3.24   </strong>Ein Übergang zwischen zwei Viewcontrollern
                                                </p>
                                                <p>Starten Sie das Projekt im Simulator, und klicken Sie den Button. Der Simulator graut
                                                   die weiße Fläche aus und schiebt von unten ein weißes Rechteck auf den Bildschirm.
                                                   Dieses Rechteck ist der neue Viewcontroller, den Sie im Storyboard angelegt haben.
                                                </p>
                                                <p>Mit dieser Konfiguration zeigt die App ihn als modalen Dialog an. Wählen Sie nun im
                                                   Attributinspektor des Segues den Stil <span class="cscreenelement">Popover</span>. Wenn Sie nun Ihr Programm starten, stürzt es mit der Meldung
                                                </p>
                                                <div class="listing"><pre class="prettyprint">*** Terminating app due to uncaught exception 'NSGenericException', reason: '-<br>[UIPopoverController dealloc] reached while popover is still visible.'<br></pre></div>
                                                <p>ab. Das liegt daran, dass Ihnen der Segue einen weiteren Controller für Ihr Popover
                                                   angelegt hat, Ihr Programm ihn aber nicht hält. Er liegt nur im Autoreleasepool, und
                                                   deshalb räumt ihn Cocoa Touch am Ende der Runloop gnadenlos weg. Um dieses Problem
                                                   zu umgehen, legen Sie eine private Property <span class="clisting">popoverController</span> mit der Klasse <span class="clisting">UIPopoverController</span><a class="indexterm" id="dodtp02ca861e-d250-49e1-a056-539f3f88b07f"></a> an. In der Methode <span class="clisting">prepareForSegue:sender:</span><a class="indexterm" id="dodtp35780fdd-d39b-4d00-8369-3e643556fedd"></a> können Sie dann den neu erzeugten Popovercontroller<a class="indexterm" id="dodtpdba37dc9-c025-4f2f-8f1c-650441ff0a56"></a> in der Property ablegen. Diese Methode ruft das Segueobjekt auf, bevor es den neuen
                                                   Viewcontroller anzeigt:
                                                </p>
                                                <div class="listing"><pre class="prettyprint">#import "SegueViewController.h"<br><br>@interface SegueViewController()<br>@property (nonatomic, strong)<br>    UIPopoverController *popoverController;<br>@end<br><br>@implementation SegueViewController<br>@synthesize popoverController;<br>- (void)prepareForSegue:(UIStoryboardSegue *)inSegue sender:(id)inSender {<br>    if([inSegue respondsToSelector:<br>        @selector(popoverController)]) {<br>        self.popoverController =<br>            [(id)inSegue popoverController];<br>    }<br>}<br>@end<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.35   </strong>Zuweisung des Popover-Controllers
                                                </p>
                                                <p>In Listing 3.35 befindet sich die Zuweisung in einem If-Block. Dadurch führt die Methode
                                                   die Zuweisung nur aus, wenn das Segueobjekt eine Methode <span class="clisting">popoverController</span> besitzt. Mit dieser Abfrage können Sie jederzeit und ohne Änderungen am Programmcode
                                                   wieder auf einen modalen Übergang zurückschalten. Die Methode <span class="clisting">prepareForSegue:sender:</span> ruft Cocoa Touch für jeden Übergang des Viewcontrollers auf. Wenn Sie also mehrere
                                                   Segueobjekte zu einem Viewcontroller anlegen, müssen Sie diese auch unterscheiden
                                                   können. Das können Sie über die String-Property <span class="clisting">identifier</span> machen, die Sie im Attributinspektor des Segues setzen können. Sie können Übergänge
                                                   auch im Code über die Methode <span class="clisting">performSegueWithIdentifier:sender:</span> auslösen. Im Beispielprogramm <span class="cdateipfad">Segue</span> geschieht das in der Methode <span class="clisting">performSegue</span>:
                                                </p>
                                                <div class="listing"><pre class="prettyprint">- (IBAction)performSegue:(id)inSender {<br>    [self performSegueWithIdentifier:@"dialog"<br>        sender:inSender];<br>}<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.36   </strong>Auslösung eines Übergangs
                                                </p>
                                                <p>Auf Popover- und die anderen Viewcontroller-Arten gehen die beiden nächsten Kapitel
                                                   noch genauer ein.
                                                </p><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a id="dodtp197deaea-4bd9-433f-a357-f8ab4a157ca6" name="dodtp197deaea-4bd9-433f-a357-f8ab4a157ca6"></a><h3 class="t3"><span class="cfett">3.2.8</span><span class="cfett"> Der Lebenszyklus eines Viewcontrollers</span><a href="#dodtpbc46c62d-db40-4709-8cbc-4580da56485f"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
                                                <p>Der Viewcontroller verwaltet den View. Er lädt also die NIB-Datei und erzeugt den
                                                   View. Wie aber wird ein Viewcontroller erzeugt?
                                                </p>
                                                <p>In Ihrem Projekt befindet sich eine weitere XIB-Datei, <span class="cdateipfad">MainWindow.xib</span><a class="indexterm" id="dodtp74a588aa-32b9-430a-ab4e-d2b394af97e6"></a>. Wenn Sie diese Datei öffnen, finden Sie darin drei Objekte.
                                                </p><a href="bilder/03_025.png" rel="lightbox" title="Die Objekte in »MainWindow.xib«"><img class="bild" border="1" src="bilderklein/klein03_025.png" alt="Abbildung"></a><p class="pbildunter"><strong>Abbildung 3.25   </strong>Die Objekte in »MainWindow.xib«
                                                </p>
                                                <p>Der Viewcontroller und das Application-Delegate<a class="indexterm" id="dodtp00a46681-674b-4391-b638-14e6656fbbf7"></a> werden über eine NIB-Datei erzeugt. Die Datei <span class="cdateipfad">MainWindow.nib</span> wird beim Programmstart automatisch mit dem Singleton <span class="clisting">UIApplication</span><a class="indexterm" id="dodtpcd6a8905-e4f4-4f11-946e-97267749f19a"></a> als <span class="cbegriff">File&#8217;s Owner</span> geladen.
                                                </p>
                                                <table width="100%" border="0" cellspacing="1" cellpadding="3">
                                                   <tbody>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellenkopf"><span class="cfett">
                                                               
                                                               
                                                               
                                                               Storyboards<a class="indexterm" id="dodtpd8349992-ff5a-433d-8565-7036997d73a8"></a>
                                                               
                                                               </span></td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext">
                                                            <p>Mit den Storyboards in iOS 5 hat Apple dieses Vorgehen geändert. Die Funktion <span class="clisting">UIApplicationMain()</span> erzeugt das Application-Delegate, weswegen der Klassenname als vierter Parameter
                                                               im Funktionsaufruf in der Datei <span class="cdateipfad">main.m</span> steht. Das Fenster erzeugt die Applikation automatisch mit dem Storyboard und weist
                                                               es dem Delegate zu.
                                                               
                                                               
                                                            </p>
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                   </tbody>
                                                </table>
                                                <p>Sie können übrigens Objekte von beliebigen Klassen in einer NIB-Datei ablegen. Wenn
                                                   Sie diese Objekte nach der Erzeugung initialisieren möchten, sollte deren Klasse eine
                                                   Initialisierungsmethode <span class="clisting">init</span> oder <span class="clisting">initWithCoder:</span> besitzen, oder Sie schreiben den Initialisierungscode in die Methode <span class="clisting">awakeFromNib</span>. Zu beliebigen Objekten in NIB-Dateien folgen später noch Beispiele.
                                                </p>
                                                <table width="100%" border="0" cellspacing="1" cellpadding="3">
                                                   <tbody>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellenkopf"><span class="cfett">
                                                               
                                                               
                                                               
                                                               Tipp
                                                               
                                                               </span></td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext">
                                                            <p>Wenn Sie einen Viewcontroller über eine NIB-Datei erzeugen, dann sollten Sie unbedingt
                                                               auf zwei Dinge achten. Erstens müssen Sie im Identitätsinspektor die Klasse des Viewcontrollers
                                                               setzen. Andernfalls wird für den Viewcontroller ein Objekt mit der Klasse <span class="clisting">UIViewController</span> erzeugt. Zweitens sollten Sie im Attributinspektor die richtige XIB-Datei mit dem
                                                               passenden View auswählen.
                                                               
                                                               
                                                            </p>
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                   </tbody>
                                                </table>
                                                <p>Sie haben bereits einige Methoden kennengelernt, die Cocoa Touch zu bestimmten Zeitpunkten
                                                   im Leben eines Viewcontrollers aufruft. Wenn Sie beispielsweise die Methode <span class="clisting">viewDidAppear:</span> überschreiben, können Sie eigenen Programmcode ausführen, unmittelbar nachdem der
                                                   View des Viewcontrollers zur Anzeige gebracht wurde. Cocoa Touch benachrichtigt Sie
                                                   also über ein bestimmtes Ereignis, das Ihren Viewcontroller betrifft. In Abbildung
                                                   3.26 ist der komplette Lebenszyklus eines Viewcontrollers<a class="indexterm" id="dodtpfca1653a-de82-4d8c-b2b1-7d0a47e23d58"></a> anhand seiner Initialisierungs- und Benachrichtigungsmethoden sowie der Property
                                                   <span class="clisting">view</span> dargestellt. Bis auf die Property <span class="clisting">view</span> dürfen Sie aber keine dieser Methoden direkt aufrufen. Sie dürfen sie nur überschreiben.
                                                </p><a href="bilder/03_026.png" rel="lightbox" title="Der Lebenszyklus eines Viewcontrollers"><img class="bild" border="1" src="bilderklein/klein03_026.png" alt="Abbildung"></a><p class="pbildunter"><strong>Abbildung 3.26   </strong>Der Lebenszyklus eines Viewcontrollers
                                                </p>
                                                <p>Die Methoden <span class="clisting">initWithCoder:</span> und <span class="clisting">awakeFromNib</span> kennen Sie ja bereits von den View-Klassen. Diese Methoden kommen zum Zuge, wenn
                                                   Sie den Viewcontroller in einer NIB-Datei oder einem Storyboard erzeugen.
                                                </p>
                                                <p>Sie können einen Viewcontroller auch aus Ihrem Programmcode erzeugen. Dazu dienen
                                                   die Methoden <span class="clisting">init</span> und <span class="clisting">initWithNibName:bundle:</span>. Wenn Sie <span class="clisting">init</span> verwenden, müssen Sie entweder die Methode <span class="clisting">loadView</span> implementieren, oder die NIB-Datei des Viewcontrollers muss bis auf die Dateiendung
                                                   genauso wie die Klasse Ihres Viewcontrollers heißen. Wenn sie allerdings einen anderslautenden
                                                   Namen haben soll, sollten Sie stattdessen die Initialisierungsmethode <span class="clisting">initWithNibName:bundle:</span><a class="indexterm" id="dodtpe659b15a-677f-4eee-a127-6b128f729f53"></a> verwenden, wobei Sie für den Bundle-Parameter <span class="clisting">nil</span> verwenden können.
                                                </p>
                                                <p>Wenn Sie Ihr Viewcontroller-Objekt erzeugen, laden Sie gewöhnlich noch nicht dessen
                                                   View. Das Überschreiben der Methode <span class="clisting">awakeFromNib</span> ist also in vielen Fällen sinnlos, da aufgrund des fehlenden Views noch nicht alle
                                                   Outlets initialisiert sind. Es sind nur die Outlets gesetzt, die in die NIB-Datei
                                                   verweisen, die den Viewcontroller erzeugt. Beispielsweise erzeugt die Datei <span class="cdateipfad">MainWindow.xib</span> den Viewcontroller <span class="clisting">AlarmClockViewController</span>. Wenn Sie von dessen Objekt innerhalb von <span class="cdateipfad">MainWindow.xib</span> ein Outlet zu einem anderen Objekt ziehen, ist dieses Outlet<a class="indexterm" id="dodtpee729733-3f7a-4147-9d2f-e3efd8b7513f"></a> bereits in der Methode <span class="clisting">awakeFromNib</span> gesetzt.
                                                </p>
                                                <p>Der Viewcontroller lädt den View beim ersten Zugriff auf die Property <span class="clisting">view</span>. Das geschieht vor der ersten Anzeige des Views. Sie können aber auch das Laden erzwingen,
                                                   indem Sie die Property auslesen. Sie können dafür Ihrem Viewcontroller beispielsweise
                                                   die folgende Methode hinzufügen:
                                                </p>
                                                <div class="listing"><pre class="prettyprint">-(void)forceLoadView {<br>    self.view;<br>}<br></pre></div>
                                                <p class="plistingunter"><strong>Listing 3.37   </strong>Methode zum Laden des Views eines Viewcontrollers
                                                </p>
                                                <p>Der Zugriff auf die Property in Zeile 2 erzwingt das Laden des Views. Den Ladezustand
                                                   des Views erfragen Sie über die Methode <span class="clisting">isViewLoaded</span><a class="indexterm" id="dodtpf3f2215f-20d9-4218-80e3-1e17712929ce"></a>.
                                                </p>
                                                <p>Die Methode <span class="clisting">loadView</span><a class="indexterm" id="dodtp8152efc6-a76d-4def-9381-c22188288776"></a> lädt den View aus der NIB-Datei. Sie können diese überschreiben, um den View durch
                                                   Code zu erzeugen. Dazu weisen Sie der Property <span class="clisting">view</span><a class="indexterm" id="dodtp56919e95-e08a-48a6-890c-d1b2089f1a64"></a> einfach Ihren erstellten View zu. In diesem Fall sollten Sie aber nicht die Methode
                                                   in der Oberklasse aufrufen. Cocoa Touch ruft nach dem Laden des Views die Methode
                                                   <span class="clisting">viewDidLoad</span><a class="indexterm" id="dodtp6a6162ad-a120-4bbc-a514-329ed7afceed"></a> auf, die Sie ja auch bereits kennengelernt haben.
                                                </p>
                                                <table width="100%" border="0" cellspacing="1" cellpadding="3">
                                                   <tbody>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellenkopf"><span class="cfett">
                                                               
                                                               
                                                               
                                                               Tipp
                                                               
                                                               </span></td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext">
                                                            <p>Wenn Sie Ihren Viewcontroller oder dessen View nach dem Laden initialisieren möchten,
                                                               sollten Sie dazu die Methode <span class="clisting">viewDidLoad</span> überschreiben. Wegen der fehlenden Outlet-Verbindungen ist die Methode <span class="clisting">awakeFromNib</span> ist in den meisten Fällen nicht dafür geeignet. Die Methode <span class="clisting">loadView</span> ist zum Laden des Views gedacht und sollte auch nur dafür überschrieben werden.
                                                               
                                                               
                                                            </p>
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                   </tbody>
                                                </table>
                                                <p>Sie können jetzt Ihren Viewcontroller beliebig oft anzeigen und wieder verschwinden
                                                   lassen. In diesen <span class="cbegriff">Anzeigezyklen</span><a class="indexterm" id="dodtpbc69b557-69d0-4f6a-a73a-0c117d2d8354"></a> ruft Cocoa Touch <span class="clisting">viewWillAppear:</span><a class="indexterm" id="dodtpdcb6d4dc-4b5e-48fa-9226-9042fd8bdb19"></a>, <span class="clisting">viewDidAppear:</span><a class="indexterm" id="dodtp9482823b-863a-471f-9e6a-76dc146bd804"></a>, <span class="clisting">viewWillDisappear:</span><a class="indexterm" id="dodtpc18c5b6e-2352-4488-9367-884c8639919a"></a> und <span class="clisting">viewDidDisappear:</span><a class="indexterm" id="dodtp4eea3202-4ea9-47f5-ad1e-d7193ab87074"></a>, die Sie bereits kennengelernt haben, auf. Das nächste Kapitel stellt mehrere Möglichkeiten
                                                   vor, Viewcontroller anzuzeigen und wieder verschwinden zu lassen.
                                                </p>
                                                <p>Ein Viewcontroller muss seinen View nicht unbedingt im Hauptspeicher halten, falls
                                                   er gerade nicht angezeigt wird. Cocoa Touch gibt den View bei knappem Speicher frei
                                                   und ruft danach die Methode <span class="clisting">viewDidUnload</span> auf. Diese Methode bildet somit das Gegenstück zu <span class="clisting">viewDidLoad</span>. Sie sollten sie überschreiben, um Outlets auf <span class="clisting">nil</span> zu setzen. Der Viewcontroller bleibt aber auch nach einem Aufruf von <span class="clisting">viewDidUnload</span> im Hauptspeicher der App. Wenn auf dessen Property <span class="clisting">view</span> zugegriffen wird, beginnt der Ladezyklus<a class="indexterm" id="dodtpb9534b2a-7baf-429c-b79d-a96a1033373b"></a> von vorne.
                                                </p>
                                                <table width="100%" border="0" cellspacing="1" cellpadding="3">
                                                   <tbody>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellenkopf"><span class="cfett">
                                                               
                                                               
                                                               
                                                               Tipp
                                                               
                                                               </span></td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      <tr>
                                                         
                                                         
                                                         <td class="tabellentext">
                                                            <p>Die Methoden <span class="clisting">viewDidLoad</span> und <span class="clisting">viewDidUnload</span> sollten Sie immer so implementieren, dass sie mehrmals aufgerufen werden können.
                                                               Sie sollten also alle Ressourcen und besonders alle Outlets freigeben, die Sie über
                                                               <span class="clisting">loadView</span> oder in <span class="clisting">viewDidLoad</span> angelegt haben. Achten Sie aber darauf, dass Sie in <span class="clisting">viewDidUnload</span> keine Ressourcen oder Outlets freigeben, die bereits vor <span class="clisting">loadView</span> erzeugt wurden. Diese Objekte können ja durch <span class="clisting">loadView</span> oder <span class="clisting">viewDidLoad</span> nicht wiederhergestellt werden.
                                                               <br><br>
                                                               Sie können die Funktionsweise übrigens auch gut im Simulator testen. Rufen Sie dazu
                                                               einfach den Menüpunkt <span class="cscreenelement">Hardware</span> · <span class="cscreenelement">Speicherwarnhinweis simulieren</span> auf.
                                                               
                                                               
                                                            </p>
                                                         </td>
                                                         
                                                         
                                                      </tr>
                                                      
                                                      
                                                      
                                                      
                                                   </tbody>
                                                </table><br><hr><a name="kommentar"></a><h3>Ihr Kommentar</h3>
                                                <p>Wie hat Ihnen das &lt;openbook&gt; gefallen? Wir freuen uns immer über Ihre freundlichen
                                                   und kritischen Rückmeldungen.
                                                </p>
                                                <form action="http://www.galileo-press.de/feedback/openbook" method="post" style="text-align: center; margin-top: 10px;"><input type="hidden" name="openbookurl" value="http://www.galileocomputing.de/katalog/openbook/apps_03_002.html"><input type="hidden" name="buchtitel" value="Apps entwickeln für iPhone und iPad"><input type="hidden" name="Kapitel" value="3 Aufwachen &#8211; analoger Wecker"><table border="0">
                                                      <tbody>
                                                         <tr>
                                                            <td><label for="name">Name</label><br></td>
                                                            <td><input type="text" name="name" id="name" size="40"><br></td>
                                                         </tr>
                                                         <tr>
                                                            <td><label for="email">E-Mail</label><br></td>
                                                            <td><input type="text" name="email" id="email" size="40"><br></td>
                                                         </tr>
                                                         <tr>
                                                            <td valign="top"><label for="comment">Ihr Kommentar</label><br></td>
                                                            <td><textarea name="comment" id="comment" rows="10" cols="40"></textarea><br></td>
                                                         </tr>
                                                         <tr>
                                                            <td></td>
                                                            <td><input type="submit" value="Kommentar absenden"></td>
                                                         </tr>
                                                      </tbody>
                                                   </table>
                                                </form>
                                             </div>
                                          </td>
                                       </tr>
                                    </tbody>
                                 </table>
                              </td>
                           </tr>
                           <tr>
                              <td width="100%" class="start" colspan="1" height="22" align="center">
                                 <table width="100%" border="0" cellspacing="0" cellpadding="0">
                                    <tbody>
                                       <tr>
                                          <td width="25%"><a href="apps_03_001.html" class="navnav"> &lt;&lt; zurück</a></td>
                                          <td width="49%">
                                             <div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div>
                                          </td>
                                          <td align="right" width="25%">
                                             <div align="right"><a href="apps_03_003.html" class="navnav">vor &gt;&gt;
                                                   </a></div>
                                          </td>
                                       </tr>
                                    </tbody>
                                 </table>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
               </td>
               <td width="10" valign="top"></td>
               <td width="160" valign="top"><table border="0" cellpadding="0" cellspacing="0" width="160">
                  <tr>
                  <td>
                  <table border="0" cellpadding="0" cellspacing="0" width="100%">
                  <tr>
                  <td class="start" height="20" colspan="2">
                  &nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opAppiP" class="autor">
                  <strong>Zum Katalog</strong></a>
                  
                  </td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2">
                  <img src="common/leer.gif" border="0" height="1" width="1"></td>
                  <td valign="top">
                  <table cellspacing="3">
                  <tr>
                  <td><a href="http://www.galileo-press.de/3521?GPP=opAppiP">
                  <img src="common/2734.png" width="126" height="100" border="0" align="left"
                  hspace="4" vspace="8" alt="Zum Katalog: Neuauflage: Apps programmieren für iPhone und iPad">
                  <br><br><br><br><br><br><strong>Neuauflage: Apps programmieren für iPhone und iPad</strong><br><img
                  src="common/pfeil_rechts5.gif" border="0" alt="">Jetzt bestellen</a><br /><br />
                  </td>
                  </tr>
                  </table>
                  </td>
                  
                  </tr>
                  </table>
                  </td>
                  </tr>
                  <tr>
                  <td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
                  </tr>
                  <tr>
                  <td>
                  <table border="0" cellpadding="0" cellspacing="0" width="100%">
                  <tr>
                  <td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Ihre Meinung?</strong></a></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td>
                  <td valign="top">
                  
                  <table cellspacing="3">
                  <tr>
                  <td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br><a href="#kommentar"><img src="common/pfeil_rechts5.gif"
                  border="0" alt="">Ihre Meinung</a>
                  <br><br></td>
                  </tr>
                  </table>
                  </td>
                  </tr>
                  </table>
                  </td>
                  </tr>
                  <tr>
                  
                  <td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
                  </tr>
                  <tr>
                  <td>
                  </td>
                  </tr>
                  
                  <tr>
                  <td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
                  </tr>
                  <tr>
                  <td>
                  <table border="0" cellpadding="0" cellspacing="0" width="100%">
                  <tr>
                  <td class="start" height="20" colspan="2">&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opAppiP"
                  class="autor"><strong>Buchempfehlungen</strong></a></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td><td valign="top">
                  <a href="http://www.galileocomputing.de/2448?GPP=opAppiP">
                  <img src="common/1658.png" width="114" height="100" border="0" align="left" hspace="4"
                  vspace="8" alt="Objective-C 2.0 & Cocoa"><br><br><br><br><br><br>&nbsp;Objective-C
                  2.0<br>&nbsp;Cocoa</a><br><br></td>
                  </tr>
                  
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td><td valign="top">
                  <a href="http://www.galileocomputing.de/2663?GPP=opAppiP">
                  <img src="common/1791.png" width="126" height="100" border="0" align="left" hspace="4"
                  vspace="8" alt="Zum Katalog: Mac OS X Lion"><br><br><br><br><br><br><br>&nbsp;Mac
                  OS X Lion</a><br><br></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td><td valign="top">
                  <a href="http://www.galileocomputing.de/2664?GPP=opAppiP">
                  <img src="common/1792.png" width="122" height="100" border="0" align="left" hspace="4"
                  vspace="8" alt="Zum Katalog: Mac OS X und UNIX"><br><br><br><br><br><br><br>&nbsp;Mac
                  OS X<br>&nbsp;und UNIX</a><br><br></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td><td valign="top">
                  <a href="http://www.galileocomputing.de/2516?GPP=opAppiP">
                  <img src="common/1697.png" width="122" height="100" border="0" align="left" hspace="4"
                  vspace="8" alt="Zum Katalog: Android 3"><br><br><br><br><br><br><br>&nbsp;Android
                  3</a><br><br></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td><td valign="top">
                  <a href="http://www.galileocomputing.de/2672?GPP=opAppiP">
                  <img src="common/1802.png" width="116" height="100" border="0" align="left" hspace="4"
                  vspace="8" alt="Zum Katalog: Java ist auch eine Insel"><br><br><br><br><br><br><br>&nbsp;Java
                  ist auch<br>&nbsp;eine Insel</a><br><br></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td><td valign="top">
                  <a href="http://www.galileocomputing.de/2556?GPP=opAppiP">
                  <img src="common/1725.png" width="124" height="100" border="0" align="left" hspace="4"
                  vspace="8" alt="Zum Katalog: CSS"><br><br><br><br><br><br><br>&nbsp;CSS</a><br><br></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td><td valign="top">
                  <a href="http://www.galileocomputing.de/2930?GPP=opAppiP">
                  <img src="common/1810.png" width="124" height="100" border="0" align="left" hspace="4"
                  vspace="8" alt="Zum Katalog: jQuery"><br><br><br><br><br><br><br>&nbsp;jQuery</a><br><br></td>
                  </tr>
                  </table></td>
                  </tr>
                  <tr>
                  <td><img src="common/leer.gif" height="2" width="1" border="0" /></img></td>
                  </tr>
                  
                  <tr>
                  <td>
                  <table border="0" cellpadding="0" cellspacing="0" width="100%">
                  <tr>
                  <td class="start" height="20" colspan="2"><span class="autor"><strong>&nbsp;Shopping</strong></span></td>
                  </tr>
                  <tr>
                  <td valign="top" class="tbl4" width="2"><img src="common/leer.gif" border="0" height="1"
                  width="1"></td>
                  <td valign="top">
                  <table cellspacing="3">
                  <tr>
                  <td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br><a href="http://www.galileocomputing.de/hilfe/Shop/?GPP=opAppiP"><img
                  src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br><br></td>
                  
                  </tr>
                  </table>
                  </td>
                  </tr>
                  </table>
                  </td>
                  </tr>
                  </table>
                  </td>
                  </tr>
                  </table>
                  <br><br><hr width="70%" align="center">
                  <div align="center">
                  <p class="standard"><strong>Copyright © Galileo Press 2011</strong><br>
                  Für Ihren privaten Gebrauch dürfen Sie die Online-Version natürlich ausdrucken.
                  Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die
                  gebundene Ausgabe: Das Werk einschließlich aller seiner Teile ist urheberrechtlich
                  geschützt. Alle Rechte vorbehalten einschließlich der Vervielfältigung, Übersetzung,
                  Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a
                  href="http://www.galileocomputing.de/?GPP=opAppiP">[Galileo Computing]</a><br><br>
                  Galileo Press, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77,
                  <a href="mailto:info@galileo-press.de">info@galileo-press.de</a></div><br><br>
               </td>
            </tr>
         </tbody>
      </table>
   </body>
</html>